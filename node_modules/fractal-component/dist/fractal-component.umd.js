(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('redux-saga'), require('redux-saga/effects'), require('react'), require('prop-types')) :
	typeof define === 'function' && define.amd ? define(['exports', 'redux-saga', 'redux-saga/effects', 'react', 'prop-types'], factory) :
	(factory((global.FractalComponent = {}),global.ReduxSaga,global.ReduxSaga.effects,global.React,global.PropTypes));
}(this, (function (exports,createSagaMiddleware,rsEffects,React,PropTypes) { 'use strict';

	var createSagaMiddleware__default = 'default' in createSagaMiddleware ? createSagaMiddleware['default'] : createSagaMiddleware;
	React = React && React.hasOwnProperty('default') ? React['default'] : React;
	PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _extends_1 = createCommonjsModule(function (module) {
	function _extends() {
	  module.exports = _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	module.exports = _extends;
	});

	function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;

		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	}

	/* global window */

	var root;

	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (typeof module !== 'undefined') {
	  root = module;
	} else {
	  root = Function('return this')();
	}

	var result = symbolObservablePonyfill(root);

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var randomString = function randomString() {
	  return Math.random().toString(36).substring(7).split('').join('.');
	};

	var ActionTypes = {
	  INIT: "@@redux/INIT" + randomString(),
	  REPLACE: "@@redux/REPLACE" + randomString(),
	  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
	    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
	  }
	};

	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (typeof obj !== 'object' || obj === null) return false;
	  var proto = obj;

	  while (Object.getPrototypeOf(proto) !== null) {
	    proto = Object.getPrototypeOf(proto);
	  }

	  return Object.getPrototypeOf(obj) === proto;
	}

	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */

	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;

	  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
	    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');
	  }

	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }

	    return enhancer(createStore)(reducer, preloadedState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }

	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */


	  function getState() {
	    if (isDispatching) {
	      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
	    }

	    return currentState;
	  }
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */


	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected the listener to be a function.');
	    }

	    if (isDispatching) {
	      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
	    }

	    var isSubscribed = true;
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      if (isDispatching) {
	        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
	      }

	      isSubscribed = false;
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */


	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;

	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }

	    return action;
	  }
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */


	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }

	    currentReducer = nextReducer;
	    dispatch({
	      type: ActionTypes.REPLACE
	    });
	  }
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */


	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object' || observer === null) {
	          throw new TypeError('Expected the observer to be an object.');
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return {
	          unsubscribe: unsubscribe
	        };
	      }
	    }, _ref[result] = function () {
	      return this;
	    }, _ref;
	  } // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.


	  dispatch({
	    type: ActionTypes.INIT
	  });
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[result] = observable, _ref2;
	}

	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */


	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	  } catch (e) {} // eslint-disable-line no-empty

	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	function compose() {
	  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }

	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }

	  if (funcs.length === 1) {
	    return funcs[0];
	  }

	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(void 0, arguments));
	    };
	  });
	}

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */

	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function () {
	      var store = createStore.apply(void 0, arguments);

	      var _dispatch = function dispatch() {
	        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
	      };

	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch() {
	          return _dispatch.apply(void 0, arguments);
	        }
	      };
	      var chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = compose.apply(void 0, chain)(store.dispatch);
	      return _objectSpread({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

	/*
	 * This is a dummy function to check if the function name has been altered by minification.
	 * If the function has been minified and NODE_ENV !== 'production', warn the user.
	 */

	function isCrushed() {}

	if (typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
	}

	var name = "fractal-component";
	var version = "3.4.2";
	var description = "`fractal-component` is a javascript library that can help you to encapsulate decoupled resuable UI component easily";
	var main = "dist/fractal-component.cjs.js";
	var module$1 = "dist/fractal-component.esm.js";
	var unpkg = "dist/fractal-component.min.umd.js";
	var files = ["dist", "src/**/*.d.ts"];
	var scripts = {
	  prettier: "prettier --write 'src/*.js' 'src/*.ts'",
	  eslint: "eslint 'src/*.js'",
	  test: "jest && yarn typings-tester --dir ./src && bundlesize",
	  bundlesize: "bundlesize",
	  clean: "rimraf dist",
	  prebuild: "npm run clean",
	  build: "rollup -c",
	  prepush: "npm run test",
	  prepare: "npm run build && cp ../../README.md ./README.md && cp ../../LICENSE ./LICENSE",
	  preversion: "npm run prepare && npm run test",
	  "release:patch": "npm version patch && npm publish && git push --follow-tags",
	  "release:minor": "npm version minor && npm publish && git push --follow-tags",
	  "release:major": "npm version major && npm publish && git push --follow-tags"
	};
	var repository = {
	  type: "git",
	  url: "git+https://github.com/t83714/fractal-component.git"
	};
	var keywords = ["javascript", "redux", "react", "saga", "fractal component", "encapsulation", "namespaced action", "namespaced store", "multicast action", "multicast messaging", "reducer hot loading", "saga hot loading"];
	var homepage = "https://github.com/t83714/fractal-component";
	var author = "Jacky Jiang <t83714@gmail.com>";
	var license = "MIT";
	var bugs = {
	  url: "https://github.com/t83714/fractal-component/issues"
	};
	var bundlesize = [{
	  path: "./dist/fractal-component.min.umd.js",
	  maxSize: "15 Kb"
	}];
	var dependencies = {
	  "@babel/runtime": "^7.0.0-rc.3",
	  lodash: "^4.17.10",
	  "object-path": "^0.11.4",
	  "object-path-immutable": "^3.0.0",
	  "prop-types": ">= 15.5.7",
	  react: ">= 15.0.0",
	  redux: "^4.0.0",
	  "redux-saga": "^1.0.0-beta.2"
	};
	var peerDependencies = {
	  "prop-types": ">= 15.5.7",
	  react: ">= 15.0.0",
	  "redux-saga": "^1.0.0-beta.2"
	};
	var devDependencies = {
	  "@babel/cli": "^7.0.0-rc.3",
	  "@babel/core": "^7.0.0-rc.3",
	  "@babel/node": "^7.0.0-rc.3",
	  "@babel/plugin-transform-runtime": "^7.0.0-rc.3",
	  "@babel/polyfill": "^7.0.0-rc.3",
	  "@babel/preset-env": "^7.0.0-rc.3",
	  "@babel/preset-react": "^7.0.0-rc.3",
	  "@babel/preset-stage-2": "^7.0.0-rc.3",
	  "@types/react": "^16.4.14",
	  "babel-core": "^7.0.0-0",
	  "babel-eslint": "^8.2.6",
	  "babel-jest": "^23.4.2",
	  "babel-plugin-annotate-pure-calls": "babel7",
	  bundlesize: "^0.17.0",
	  eslint: "^5.2.0",
	  "eslint-plugin-jest": "^21.22.0",
	  "eslint-plugin-react": "^7.11.1",
	  jest: "^23.5.0",
	  "npm-run-all": "^4.1.3",
	  prettier: "^1.13.7",
	  "redux-devtools-extension": "^2.13.5",
	  rimraf: "^2.6.2",
	  rollup: "^0.64.1",
	  "rollup-plugin-babel": "4.0.0-beta.1",
	  "rollup-plugin-commonjs": "^9.1.5",
	  "rollup-plugin-json": "^3.0.0",
	  "rollup-plugin-node-builtins": "^2.1.2",
	  "rollup-plugin-node-resolve": "^3.3.0",
	  "rollup-plugin-replace": "^2.0.0",
	  "rollup-plugin-uglify": "^4.0.0",
	  typescript: "^3.1.1",
	  "typings-tester": "^0.3.2"
	};
	var typings = "./src/index.d.ts";
	var npmName = "fractal-component";
	var npmFileMap = [{
	  basePath: "/dist/",
	  files: ["*.js"]
	}];
	var pkg = {
	  name: name,
	  version: version,
	  description: description,
	  main: main,
	  module: module$1,
	  unpkg: unpkg,
	  files: files,
	  scripts: scripts,
	  repository: repository,
	  keywords: keywords,
	  homepage: homepage,
	  author: author,
	  license: license,
	  "private": false,
	  bugs: bugs,
	  bundlesize: bundlesize,
	  dependencies: dependencies,
	  peerDependencies: peerDependencies,
	  devDependencies: devDependencies,
	  typings: typings,
	  npmName: npmName,
	  npmFileMap: npmFileMap
	};

	var NAMESPACED =
	/*#__PURE__*/
	Symbol("@@" + pkg.name + "/NAMESPACED");

	/**
	 * The code of file is modified from [redux-saga](https://github.com/redux-saga/redux-saga) project
	 * @redux-saga/is module
	 */
	var undef = function undef(v) {
	  return v === null || v === undefined;
	};
	var notUndef = function notUndef(v) {
	  return v !== null && v !== undefined;
	};
	var func = function func(f) {
	  return typeof f === 'function';
	};
	var number = function number(n) {
	  return typeof n === 'number';
	};
	var string = function string(s) {
	  return typeof s === 'string';
	};
	var array = Array.isArray;
	var object = function object(obj) {
	  return obj && !array(obj) && typeof obj === 'object';
	};
	var promise = function promise(p) {
	  return p && func(p.then);
	};
	var iterator = function iterator(it) {
	  return it && func(it.next) && func(it.throw);
	};
	var iterable = function iterable(it) {
	  return it && func(Symbol) ? func(it[Symbol.iterator]) : array(it);
	};
	var observable = function observable(ob) {
	  return ob && func(ob.subscribe);
	};
	var buffer = function buffer(buf) {
	  return buf && func(buf.isEmpty) && func(buf.take) && func(buf.put);
	};
	var pattern = function pattern(pat) {
	  return pat && (string(pat) || symbol(pat) || func(pat) || array(pat));
	};
	var channel = function channel(ch) {
	  return ch && func(ch.take) && func(ch.close);
	};
	var stringableFunc = function stringableFunc(f) {
	  return func(f) && f.hasOwnProperty('toString');
	};
	var symbol = function symbol(sym) {
	  return Boolean(sym) && typeof Symbol === 'function' && sym.constructor === Symbol && sym !== Symbol.prototype;
	};
	var bool = typeof v === "boolean";
	var action = function action(v) {
	  return object(v) && symbol(v.type);
	};
	var namespacedAction = function namespacedAction(v) {
	  return action(v) && v[NAMESPACED];
	};

	var is = /*#__PURE__*/Object.freeze({
		undef: undef,
		notUndef: notUndef,
		func: func,
		number: number,
		string: string,
		array: array,
		object: object,
		promise: promise,
		iterator: iterator,
		iterable: iterable,
		observable: observable,
		buffer: buffer,
		pattern: pattern,
		channel: channel,
		stringableFunc: stringableFunc,
		symbol: symbol,
		bool: bool,
		action: action,
		namespacedAction: namespacedAction
	});

	var devMode = false;

	if (typeof process === "object" && notUndef(process.env) && notUndef("development") && "development" === "development") {
	  devMode = true;
	}

	var IS_NODE = null;
	var isInNode = function isInNode() {
	  if (IS_NODE === null) {
	    IS_NODE = typeof process === "object" && Object.prototype.toString.call(process) === "[object process]";
	  }

	  return IS_NODE;
	};
	/**
	 * Modified from https://github.com/adamhalasz/uniqid
	 */

	var machineInfo = null;
	var getMachineInfo = function getMachineInfo() {
	  if (machineInfo !== null) return machineInfo;

	  if (!isInNode()) {
	    machineInfo = {
	      pid: null,
	      macAddr: "",
	      macAddrInt: null
	    };
	    return machineInfo;
	  }

	  var macAddr = "",
	      macAddrInt = null,
	      pid = null;

	  try {
	    var networkInterfaces = require("os").networkInterfaces();

	    var interface_key;

	    for (interface_key in networkInterfaces) {
	      var networkInterface = networkInterfaces[interface_key];
	      var length = networkInterface.length;

	      for (var i = 0; i < length; i++) {
	        if (networkInterface[i].mac && networkInterface[i].mac != "00:00:00:00:00:00") {
	          macAddr = networkInterface[i].mac;
	          break;
	        }
	      }

	      if (macAddr !== "") break;
	    }

	    pid = process && process.pid ? process.pid : null;
	    macAddrInt = macAddr ? parseInt(macAddr.replace(/\:|\D+/gi, "")) : null;
	    if (isNaN(macAddrInt)) macAddrInt = null;
	  } catch (e) {}

	  machineInfo = {
	    pid: pid,
	    macAddr: macAddr,
	    macAddrInt: macAddrInt
	  };
	  return machineInfo;
	};
	var lastTimeStamp = null;
	var uniqid = function uniqid(prefix) {
	  var _getMachineInfo = getMachineInfo(),
	      pid = _getMachineInfo.pid,
	      mac = _getMachineInfo.macAddrInt;

	  if (number(pid) && pid) {
	    pid = pid.toString(36);
	  } else {
	    pid = "";
	  }

	  if (number(mac) && mac) {
	    mac = mac.toString(36);
	  } else {
	    mac = "";
	  }

	  var now = Date.now();
	  var last = lastTimeStamp || now;
	  lastTimeStamp = now > last ? now : last + 1;
	  return (prefix || "") + mac + pid + lastTimeStamp.toString(36);
	};
	var getPackageName = function getPackageName() {
	  return pkg.name;
	};
	var getPackageVersion = function getPackageVersion() {
	  return pkg.version;
	};
	var isDevMode = function isDevMode() {
	  return devMode;
	};
	var log = function log(message, level, error) {
	  if (level === void 0) {
	    level = "log";
	  }

	  if (error === void 0) {
	    error = "";
	  }

	  /*eslint-disable no-console*/
	  if (typeof window === "undefined") {
	    console.log("fractal-component " + level + ": " + message + "\n" + (error && error.stack || error));
	  } else {
	    console[level](message, error);
	  }
	};
	var trim = function trim(v) {
	  if (!v) return "";
	  if (string(v)) return v.trim();
	  var s = String(v);
	  return s.trim();
	};
	var konst = function konst(v) {
	  return function () {
	    return v;
	  };
	};
	var kTrue =
	/*#__PURE__*/
	konst(true);
	var kFalse =
	/*#__PURE__*/
	konst(false);
	var noop = function noop() {};
	var identity = function identity(v) {
	  return v;
	};
	var createClassNameGenerator = function createClassNameGenerator(namespace) {
	  var ruleCounter = 0;
	  var runtimeNamespace = namespace ? namespace : this ? this.namespace : "";

	  if (!runtimeNamespace) {
	    throw new Error("createClassNameGenerator: namespace cannot be empty!");
	  }

	  var prefix = runtimeNamespace.replace(/[^a-zA-Z0-9-]/g, "-");
	  return function () {
	    ruleCounter += 1;
	    return prefix + "-" + ruleCounter;
	  };
	}; // --- avoid toString to be converted to ""+ by minifier

	var symbolToString = function symbolToString(s) {
	  return Symbol.prototype.toString.apply(s);
	};

	var utils = /*#__PURE__*/Object.freeze({
		isInNode: isInNode,
		getMachineInfo: getMachineInfo,
		uniqid: uniqid,
		getPackageName: getPackageName,
		getPackageVersion: getPackageVersion,
		isDevMode: isDevMode,
		log: log,
		trim: trim,
		konst: konst,
		kTrue: kTrue,
		kFalse: kFalse,
		noop: noop,
		identity: identity,
		is: is,
		createClassNameGenerator: createClassNameGenerator,
		symbolToString: symbolToString
	});

	var PathContext =
	/*#__PURE__*/
	function () {
	  function PathContext(cwd) {
	    this.cwd = normalize(cwd);
	    if (this.cwd.indexOf("*") !== -1) throw new Error("`cwd` cannot contains `*`");

	    if (this.cwd.indexOf(".") !== -1) {
	      this.cwd = this.compressPath(this.cwd);
	    }
	  }

	  var _proto = PathContext.prototype;

	  _proto.getLastSegment = function getLastSegment() {
	    var idx = this.cwd.lastIndexOf("/");
	    if (idx >= this.cwd.length - 1) return "";
	    return this.cwd.substring(idx + 1);
	  };

	  _proto.compressPath = function compressPath(paths, ignoreExcessDoubleDot) {
	    if (ignoreExcessDoubleDot === void 0) {
	      ignoreExcessDoubleDot = true;
	    }

	    if (string(paths)) paths = [paths];
	    var calculatedParts = [];
	    paths.map(function (p) {
	      return p.trim();
	    }).forEach(function (p) {
	      if (p.indexOf("*") !== -1) throw new Error("Failed to resolve path: path segments cannot contain `*`");
	      p.split("/").forEach(function (item) {
	        item = trim(item);

	        switch (item) {
	          case "":
	            break;

	          case ".":
	            break;

	          case "..":
	            if (calculatedParts.length) {
	              calculatedParts.pop();
	            } else {
	              if (!ignoreExcessDoubleDot) {
	                calculatedParts.push("..");
	              }
	            }

	            break;

	          default:
	            calculatedParts.push(item);
	        }
	      });
	    });
	    return calculatedParts.join("/");
	  };

	  _proto.resolve = function resolve() {
	    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
	      paths[_key] = arguments[_key];
	    }

	    var pathItems = [this.cwd].concat(paths);
	    return this.compressPath(pathItems);
	  };

	  _proto.convertNamespacedAction = function convertNamespacedAction(action$$1, relativeDispatchPath) {
	    var _extends2;

	    if (!object(action$$1)) {
	      throw new Error("Tried to dispatch action in invalid type: " + typeof action$$1);
	    }

	    if (!symbol(action$$1.type)) {
	      throw new Error("action.type cannot be " + typeof action$$1.type + " and must be a Symbol");
	    }

	    var path = normalize(relativeDispatchPath);
	    var isMulticast = false;

	    if (path.length && path[path.length - 1] === "*") {
	      isMulticast = true;
	      path = normalize(path.substring(0, path.length - 1));
	    }

	    var absolutePath = this.resolve(path);

	    var newAction = _extends_1({}, action$$1, (_extends2 = {}, _extends2[NAMESPACED] = true, _extends2.isMulticast = isMulticast, _extends2.currentSenderPath = this.cwd, _extends2.currentDispatchPath = absolutePath, _extends2.currentComponentId = this.getLastSegment(), _extends2));

	    if (!newAction.senderPath) newAction.senderPath = newAction.currentSenderPath;
	    if (!newAction.dispatchPath) newAction.dispatchPath = newAction.currentDispatchPath;
	    if (!newAction.componentId) newAction.componentId = newAction.currentComponentId;
	    return newAction;
	  };

	  return PathContext;
	}();

	var PathRegistry =
	/*#__PURE__*/
	function () {
	  function PathRegistry(shouldKeepOrder) {
	    if (shouldKeepOrder === void 0) {
	      shouldKeepOrder = false;
	    }

	    this.paths = [];
	    this.dataStore = {};
	    this.shouldKeepOrder = shouldKeepOrder;
	  }

	  var _proto2 = PathRegistry.prototype;

	  _proto2.destroy = function destroy() {
	    this.paths = [];
	    this.dataStore = {};
	  };

	  _proto2.add = function add(path, data) {
	    if (data === void 0) {
	      data = undefined;
	    }

	    validate(path);
	    path = normalize(path);
	    if (this.paths.indexOf(path) !== -1) return null;
	    this.paths.push(path);

	    if (this.shouldKeepOrder) {
	      this.paths.sort(function (a, b) {
	        if (a.length < b.length) return -1;else if (a.length > b.length) return 1;
	      });
	    }

	    if (notUndef(data)) this.dataStore[path] = data;
	    return path;
	  };

	  _proto2.getPathData = function getPathData(path) {
	    var data = this.dataStore[path];
	    return data ? data : {};
	  };

	  _proto2.setPathData = function setPathData(path, data) {
	    this.dataStore[path] = data;
	  };

	  _proto2.mergePathData = function mergePathData(path, data) {
	    if (object(this.dataStore[path])) {
	      this.dataStore[path] = Object.assign({}, this.dataStore[path], data);
	    } else {
	      this.dataStore[path] = data;
	    }
	  };

	  _proto2.removePathData = function removePathData(path) {
	    delete this.dataStore[path];
	  };

	  _proto2.foreach = function foreach(iteratee) {
	    var _this = this;

	    Object.keys(this.dataStore).forEach(function (key) {
	      return iteratee(_this.dataStore[key], key);
	    });
	  };

	  _proto2.map = function map(iteratee) {
	    var _this2 = this;

	    return Object.keys(this.dataStore).map(function (key) {
	      return iteratee(_this2.dataStore[key], key);
	    });
	  };

	  _proto2.searchPathByPathData = function searchPathByPathData(predictFunc) {
	    var _this3 = this;

	    if (!func(predictFunc)) throw new Error("searchPathByPathData require function as parameter!");
	    return Object.keys(this.dataStore).find(function (key) {
	      return predictFunc(_this3.dataStore[key]);
	    });
	  };

	  _proto2.remove = function remove(path) {
	    validate(path);
	    path = normalize(path);
	    this.paths = this.paths.filter(function (item) {
	      return item !== path;
	    });
	    delete this.dataStore[path];
	  };

	  _proto2.exist = function exist(path) {
	    if (this.paths.indexOf(path) !== -1) return true;else return false;
	  };

	  _proto2.isAllowedMulticast = function isAllowedMulticast(path, actionType) {
	    var _this$getPathData = this.getPathData(path),
	        allowedIncomingMulticastActionTypes = _this$getPathData.allowedIncomingMulticastActionTypes;

	    if (!allowedIncomingMulticastActionTypes) return false;
	    if (string(allowedIncomingMulticastActionTypes) && allowedIncomingMulticastActionTypes === "*") return true;

	    if (symbol(allowedIncomingMulticastActionTypes)) {
	      return allowedIncomingMulticastActionTypes === actionType;
	    }

	    if (!array(allowedIncomingMulticastActionTypes)) {
	      throw new Error("PathRegistry.isAllowedMulticast: invalid `allowedIncomingMulticastActionTypes` option type. ");
	    }

	    return allowedIncomingMulticastActionTypes.indexOf(actionType) !== -1;
	  };
	  /**
	   *
	   * @param {Action} action dispatch Action
	   *
	   */


	  _proto2.searchDispatchPaths = function searchDispatchPaths(action$$1) {
	    var _this4 = this;

	    if (!this.shouldKeepOrder) {
	      throw new Error("`searchDispatchPaths` method requires PathRegistry to be initialised in `keepOrder` mode.");
	    }

	    if (action$$1[NAMESPACED] !== true) {
	      throw new Error("PathRegistry: cannot searchDispatchPaths for a non-namespaced action.");
	    }

	    var dispatchPath = action$$1.currentDispatchPath,
	        isMulticast = action$$1.isMulticast;

	    if (!isMulticast) {
	      if (this.exist(dispatchPath)) return [dispatchPath];else return [];
	    }

	    var rejectedPaths = [];
	    return this.paths.filter(function (item) {
	      // --- only include sub branch paths. e.g. `dispatchPath` is part of and shorter than `item`
	      // --- exact same path should also be included e.g. item === dispatchPath
	      if (dispatchPath !== "" && // --- empty dispatchPath indicates a multicast action dispatched at root level
	      item.indexOf(dispatchPath + "/") !== 0 && item !== dispatchPath) {
	        return false;
	      }

	      if (rejectedPaths.findIndex(function (path) {
	        return item.indexOf(path + "/") !== -1;
	      }) !== -1) {
	        // --- if parent container reject this action
	        // --- child containers won't see it
	        // --- this logic requires that all paths are added in order
	        // --- i.e. from string length lower to higher
	        return false;
	      }

	      var _this4$getPathData = _this4.getPathData(item),
	          allowedIncomingMulticastActionTypes = _this4$getPathData.allowedIncomingMulticastActionTypes;

	      if (allowedIncomingMulticastActionTypes === "*") {
	        /**
	         * If a component is set to accept `any` action types (i.e. `allowedIncomingMulticastActionTypes` set to "*"), the dispatch path
	         * must on or beyond local namespace boundary before a multicast action is dispatched to this component.
	         * e.g. For a component:
	         * Namespace Prefix                Namespace                   ComponentID
	         * exampleApp/Gifs   /  io.github.t83714/ActionForwarder    /  sdjiere
	         * The local namespace boundary is between `exampleApp/Gifs` and `io.github.t83714/ActionForwarder/sdjiere`
	         * Actions dispatched on `exampleApp/Gifs` (on boundary) or
	         * `exampleApp/Gifs/io.github.t83714` (beyond the boundary) will be accepted by this component.
	         * Actions dispatched on `exampleApp` will not be accepted by this component.
	         */
	        var _ref = _this4.dataStore[item] ? _this4.dataStore[item] : {},
	            localPathPos = _ref.localPathPos;

	        if (!number(localPathPos)) return true;
	        if (dispatchPath.length - 1 >= localPathPos - 2) return true;
	        rejectedPaths.push(item);
	        return false;
	      } else {
	        // --- only components / registered path accepts Multicast action will be included.
	        var isAllowed = _this4.isAllowedMulticast(item, action$$1.type);

	        if (!isAllowed) {
	          rejectedPaths.push(item);
	        }

	        return isAllowed;
	      }
	    });
	  };

	  return PathRegistry;
	}();
	function validate(path) {
	  if (path.indexOf("*") !== -1) {
	    throw new Error("path cannot contain `*`");
	  }
	}
	function normalize(path, toLowerCase) {
	  if (toLowerCase === void 0) {
	    toLowerCase = false;
	  }

	  path = trim(path);
	  if (toLowerCase) path = path.toLowerCase();

	  if (path[0] === "/") {
	    if (path.length === 1) {
	      path = "";
	    } else {
	      path = path.substring(1);
	    }
	  }

	  if (path[path.length - 1] === "/") {
	    if (path.length === 1) {
	      path = "";
	    } else {
	      path = path.substring(0, path.length - 1);
	    }
	  }

	  return path;
	}

	var objectPath = createCommonjsModule(function (module) {
	(function (root, factory){

	  /*istanbul ignore next:cant test*/
	  {
	    module.exports = factory();
	  }
	})(commonjsGlobal, function(){

	  var toStr = Object.prototype.toString;
	  function hasOwnProperty(obj, prop) {
	    if(obj == null) {
	      return false
	    }
	    //to handle objects with null prototypes (too edge case?)
	    return Object.prototype.hasOwnProperty.call(obj, prop)
	  }

	  function isEmpty(value){
	    if (!value) {
	      return true;
	    }
	    if (isArray(value) && value.length === 0) {
	        return true;
	    } else if (typeof value !== 'string') {
	        for (var i in value) {
	            if (hasOwnProperty(value, i)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    return false;
	  }

	  function toString(type){
	    return toStr.call(type);
	  }

	  function isObject(obj){
	    return typeof obj === 'object' && toString(obj) === "[object Object]";
	  }

	  var isArray = Array.isArray || function(obj){
	    /*istanbul ignore next:cant test*/
	    return toStr.call(obj) === '[object Array]';
	  };

	  function isBoolean(obj){
	    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';
	  }

	  function getKey(key){
	    var intKey = parseInt(key);
	    if (intKey.toString() === key) {
	      return intKey;
	    }
	    return key;
	  }

	  function factory(options) {
	    options = options || {};

	    var objectPath = function(obj) {
	      return Object.keys(objectPath).reduce(function(proxy, prop) {
	        if(prop === 'create') {
	          return proxy;
	        }

	        /*istanbul ignore else*/
	        if (typeof objectPath[prop] === 'function') {
	          proxy[prop] = objectPath[prop].bind(objectPath, obj);
	        }

	        return proxy;
	      }, {});
	    };

	    function hasShallowProperty(obj, prop) {
	      return (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop))
	    }

	    function getShallowProperty(obj, prop) {
	      if (hasShallowProperty(obj, prop)) {
	        return obj[prop];
	      }
	    }

	    function set(obj, path, value, doNotReplace){
	      if (typeof path === 'number') {
	        path = [path];
	      }
	      if (!path || path.length === 0) {
	        return obj;
	      }
	      if (typeof path === 'string') {
	        return set(obj, path.split('.').map(getKey), value, doNotReplace);
	      }
	      var currentPath = path[0];
	      var currentValue = getShallowProperty(obj, currentPath);
	      if (path.length === 1) {
	        if (currentValue === void 0 || !doNotReplace) {
	          obj[currentPath] = value;
	        }
	        return currentValue;
	      }

	      if (currentValue === void 0) {
	        //check if we assume an array
	        if(typeof path[1] === 'number') {
	          obj[currentPath] = [];
	        } else {
	          obj[currentPath] = {};
	        }
	      }

	      return set(obj[currentPath], path.slice(1), value, doNotReplace);
	    }

	    objectPath.has = function (obj, path) {
	      if (typeof path === 'number') {
	        path = [path];
	      } else if (typeof path === 'string') {
	        path = path.split('.');
	      }

	      if (!path || path.length === 0) {
	        return !!obj;
	      }

	      for (var i = 0; i < path.length; i++) {
	        var j = getKey(path[i]);

	        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||
	          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {
	          obj = obj[j];
	        } else {
	          return false;
	        }
	      }

	      return true;
	    };

	    objectPath.ensureExists = function (obj, path, value){
	      return set(obj, path, value, true);
	    };

	    objectPath.set = function (obj, path, value, doNotReplace){
	      return set(obj, path, value, doNotReplace);
	    };

	    objectPath.insert = function (obj, path, value, at){
	      var arr = objectPath.get(obj, path);
	      at = ~~at;
	      if (!isArray(arr)) {
	        arr = [];
	        objectPath.set(obj, path, arr);
	      }
	      arr.splice(at, 0, value);
	    };

	    objectPath.empty = function(obj, path) {
	      if (isEmpty(path)) {
	        return void 0;
	      }
	      if (obj == null) {
	        return void 0;
	      }

	      var value, i;
	      if (!(value = objectPath.get(obj, path))) {
	        return void 0;
	      }

	      if (typeof value === 'string') {
	        return objectPath.set(obj, path, '');
	      } else if (isBoolean(value)) {
	        return objectPath.set(obj, path, false);
	      } else if (typeof value === 'number') {
	        return objectPath.set(obj, path, 0);
	      } else if (isArray(value)) {
	        value.length = 0;
	      } else if (isObject(value)) {
	        for (i in value) {
	          if (hasShallowProperty(value, i)) {
	            delete value[i];
	          }
	        }
	      } else {
	        return objectPath.set(obj, path, null);
	      }
	    };

	    objectPath.push = function (obj, path /*, values */){
	      var arr = objectPath.get(obj, path);
	      if (!isArray(arr)) {
	        arr = [];
	        objectPath.set(obj, path, arr);
	      }

	      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
	    };

	    objectPath.coalesce = function (obj, paths, defaultValue) {
	      var value;

	      for (var i = 0, len = paths.length; i < len; i++) {
	        if ((value = objectPath.get(obj, paths[i])) !== void 0) {
	          return value;
	        }
	      }

	      return defaultValue;
	    };

	    objectPath.get = function (obj, path, defaultValue){
	      if (typeof path === 'number') {
	        path = [path];
	      }
	      if (!path || path.length === 0) {
	        return obj;
	      }
	      if (obj == null) {
	        return defaultValue;
	      }
	      if (typeof path === 'string') {
	        return objectPath.get(obj, path.split('.'), defaultValue);
	      }

	      var currentPath = getKey(path[0]);
	      var nextObj = getShallowProperty(obj, currentPath);
	      if (nextObj === void 0) {
	        return defaultValue;
	      }

	      if (path.length === 1) {
	        return nextObj;
	      }

	      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);
	    };

	    objectPath.del = function del(obj, path) {
	      if (typeof path === 'number') {
	        path = [path];
	      }

	      if (obj == null) {
	        return obj;
	      }

	      if (isEmpty(path)) {
	        return obj;
	      }
	      if(typeof path === 'string') {
	        return objectPath.del(obj, path.split('.'));
	      }

	      var currentPath = getKey(path[0]);
	      if (!hasShallowProperty(obj, currentPath)) {
	        return obj;
	      }

	      if(path.length === 1) {
	        if (isArray(obj)) {
	          obj.splice(currentPath, 1);
	        } else {
	          delete obj[currentPath];
	        }
	      } else {
	        return objectPath.del(obj[currentPath], path.slice(1));
	      }

	      return obj;
	    };

	    return objectPath;
	  }

	  var mod = factory();
	  mod.create = factory;
	  mod.withInheritedProps = factory({includeInheritedProps: true});
	  return mod;
	});
	});

	var defaultOptions = {
	  saga: null,
	  initState: {},
	  reducer: null,
	  namespace: null,
	  namespacePrefix: null,
	  componentId: null,
	  persistState: true,
	  //--- when `allowedIncomingMulticastActionTypes` is string
	  //--- only "*" is accepted (means accepting any actionTypes)
	  allowedIncomingMulticastActionTypes: null,
	  isServerSideRendering: false
	};
	var pkgName =
	/*#__PURE__*/
	getPackageName();
	var COMPONENT_MANAGER_LOCAL_KEY =
	/*#__PURE__*/
	Symbol("COMPONENT_MANAGER_LOCAL_KEY");

	var ComponentManager =
	/*#__PURE__*/
	function () {
	  function ComponentManager(componentInstance, options, appContainer) {
	    this.createClassNameGenerator = createClassNameGenerator.bind(this);
	    this.componentInstance = componentInstance;
	    this.options = _extends_1({}, defaultOptions, options);
	    this.appContainer = appContainer;
	    this.store = appContainer.store;
	    this.isInitialized = false;
	    this.isDestroyed = false;
	    this.initCallback = noop;
	    this.destroyCallback = noop;
	    this.storeListener = bindStoreListener.bind(this);
	    this.storeListenerUnsubscribe = null;
	    this.managingInstance = componentInstance;
	    this.displayName = getComponentName(this.managingInstance);
	    var settleStringSettingFunc = settleStringSetting.bind(this);

	    if (!this.namespacePrefix) {
	      this.namespacePrefix = normalize(settleStringSettingFunc(this.options.namespacePrefix));
	    }

	    if (this.namespacePrefix.indexOf("*") !== -1) throw new Error("`namespacePrefix` cannot contain `*`.");
	    this.namespace = normalize(settleStringSettingFunc(this.options.namespace));
	    if (this.namespace.indexOf("*") !== -1) throw new Error("`Namespace` cannot contain `*`.");
	    if (!this.namespace) throw new Error("Missing Component `namespace`: Component `namespace` must be specified.");
	    this.isAutoComponentId = false;
	    this.componentId = normalize(settleStringSettingFunc(this.options.componentId));
	    if (this.componentId.indexOf("/") !== -1 || this.componentId.indexOf("*") !== -1) throw new Error("`Component ID` cannot contain `/` or `*`.");

	    if (!this.componentId) {
	      this.isAutoComponentId = true;
	      this.componentId = this.appContainer.componentRegistry.createComponentId(this.namespacePrefix, this.namespace);
	    }

	    if (this.componentInstance.props && this.componentInstance.props.namespacePrefix) {
	      this.namespacePrefix = normalize(settleStringSettingFunc(this.componentInstance.props.namespacePrefix));
	    }

	    this.isServerSideRendering = this.options.isServerSideRendering;
	    this.persistState = this.options.persistState;
	    this.fullNamespace = fullNamespace.bind(this)();
	    this.fullPath = fullPath.bind(this)();
	    this.fullLocalPath = fullLocalPath.bind(this)();
	    this.allowedIncomingMulticastActionTypes = this.options.allowedIncomingMulticastActionTypes;
	    determineInitState.apply(this);
	  }

	  var _proto = ComponentManager.prototype;

	  _proto.enhanceComponentInstance = function enhanceComponentInstance(initCallback, destroyCallback) {
	    if (initCallback === void 0) {
	      initCallback = null;
	    }

	    if (destroyCallback === void 0) {
	      destroyCallback = null;
	    }

	    if (initCallback) {
	      this.initCallback = initCallback;
	    }

	    if (destroyCallback) {
	      this.destroyCallback = destroyCallback;
	    } //--- should NOT shallow copy to avoid unnecessary render


	    this.componentInstance.state = this.initState;

	    if (this.isServerSideRendering) {
	      this.setState = noop;
	    } else {
	      this.setState = this.componentInstance.setState.bind(this.componentInstance);
	    }

	    this.componentInstance.setState = function () {
	      throw new Error("This component is managed by `" + pkgName + "`. You should dispatch action to mutate component state.");
	    };

	    this.storeListenerUnsubscribe = this.store.subscribe(this.storeListener);
	    this.componentInstance[COMPONENT_MANAGER_LOCAL_KEY] = this;

	    if (this.isServerSideRendering) {
	      this.init();
	    } else {
	      injectLifeHookers.apply(this);
	    }
	  };

	  _proto.dispatch = function dispatch(action$$1, relativeDispatchPath) {
	    if (relativeDispatchPath === void 0) {
	      relativeDispatchPath = "";
	    }

	    var pc = new PathContext(this.fullPath);
	    var namespacedAction$$1 = pc.convertNamespacedAction(action$$1, relativeDispatchPath); // --- query action Type's original namespace so that it can be serialised correctly if needed

	    var namespace = this.appContainer.actionRegistry.findNamespaceByActionType(namespacedAction$$1.type);

	    if (!namespace) {
	      log("Cannot locate namespace for Action `" + symbolToString(namespacedAction$$1.type) + "`: `" + symbolToString(namespacedAction$$1.type) + "` needs to be registered otherwise the action won't be serializable.");
	    } else {
	      namespacedAction$$1.namespace = namespace;
	    }

	    return this.store.dispatch(namespacedAction$$1);
	  };

	  _proto.init = function init() {
	    if (this.isInitialized || this.isDestroyed) return;
	    this.initCallback(this);
	    this.isInitialized = true;
	  };

	  _proto.getNamespaceData = function getNamespaceData() {
	    return this.appContainer.namespaceRegistry.getData(this.namespace);
	  };

	  _proto.destroy = function destroy() {
	    this.isDestroyed = true;
	    if (!this.isInitialized) return;
	    this.destroyCallback(this);

	    if (this.storeListenerUnsubscribe) {
	      this.storeListenerUnsubscribe();
	      this.storeListenerUnsubscribe = null;
	    }

	    this.appContainer = null;
	    this.store = null;
	    this.isInitialized = false;
	  };

	  return ComponentManager;
	}();

	function bindStoreListener() {
	  var state = objectPath.get(this.store.getState(), this.fullPath.split("/"));
	  if (state === this.componentInstance.state) return;
	  this.setState(state);
	}

	function determineInitState() {
	  var initState = this.managingInstance.state;

	  if (!initState) {
	    initState = this.options.initState;
	  }

	  if (!initState) {
	    initState = {};
	  }

	  this.initState = _extends_1({}, initState);
	}

	function injectLifeHookers() {
	  var origComponentDidMount = this.managingInstance.componentDidMount ? this.managingInstance.componentDidMount : noop;
	  var origComponentWillUnmount = this.managingInstance.componentWillUnmount ? this.managingInstance.componentWillUnmount : noop;
	  this.managingInstance.componentDidMount = handlerComponentDidMount.bind(this, origComponentDidMount);
	  this.managingInstance.componentWillUnmount = handlerComponentWillUnmount.bind(this, origComponentWillUnmount);
	}

	function handlerComponentDidMount(originalHandler) {
	  this.init();

	  if (originalHandler && typeof originalHandler === "function") {
	    originalHandler.apply(this.managingInstance);
	  }
	}

	function handlerComponentWillUnmount(originalHandler) {
	  if (originalHandler && typeof originalHandler === "function") {
	    originalHandler.apply(this.managingInstance);
	  }

	  this.destroy();
	}

	function fullNamespace() {
	  var parts = [];
	  if (this.namespacePrefix) parts.push(this.namespacePrefix);
	  if (this.namespace) parts.push(this.namespace);
	  return parts.join("/");
	}

	function fullPath() {
	  var parts = [];
	  if (this.fullNamespace) parts.push(this.fullNamespace);
	  parts.push(this.componentId);
	  return parts.join("/");
	}

	function fullLocalPath() {
	  var parts = [];
	  if (this.namespace) parts.push(this.namespace);
	  parts.push(this.componentId);
	  return parts.join("/");
	}

	function getComponentName(componentInstance) {
	  try {
	    return componentInstance.constructor.displayName || componentInstance.constructor.name || "Component";
	  } catch (e) {
	    return "Component";
	  }
	}

	function settleStringSetting(setting) {
	  if (!setting) return "";

	  if (typeof setting === "function") {
	    try {
	      var value = setting.bind(this, this.displayName, this.managingInstance)();
	      if (!value) return "";
	      return value;
	    } catch (e) {
	      log("Failed to retrieve setting via executing generating function: " + e.getMessage(), "error", e);
	      return "";
	    }
	  } else {
	    return String(setting);
	  }
	}

	var defaultOptions$1 = {
	  isServerSideRendering: false
	};

	var ComponentRegistry =
	/*#__PURE__*/
	function () {
	  function ComponentRegistry(appContainer, options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.appContainer = appContainer;
	    this.options = _extends_1({}, defaultOptions$1, options);
	    this.pathRegistry = new PathRegistry();
	    this.componentManagerStore = {};
	    this.componentAutoIdCounter = {};
	  }

	  var _proto = ComponentRegistry.prototype;

	  _proto.createComponentId = function createComponentId() {
	    for (var _len = arguments.length, pathItems = new Array(_len), _key = 0; _key < _len; _key++) {
	      pathItems[_key] = arguments[_key];
	    }

	    var path = pathItems.filter(function (item) {
	      return item ? true : false;
	    }).join("/");

	    if (number(this.componentAutoIdCounter[path])) {
	      this.componentAutoIdCounter[path] += 1;
	    } else {
	      this.componentAutoIdCounter[path] = 0;
	    }

	    return "c" + this.componentAutoIdCounter[path];
	  };

	  _proto.register = function register(componentInstance, options) {
	    var runTimeOptions = _extends_1({}, this.options, options);

	    var manager = new ComponentManager(componentInstance, runTimeOptions, this.appContainer);

	    if (this.componentManagerStore[manager.fullPath]) {
	      throw new Error("Try to register component to an existing path: " + manager.fullPath);
	    }

	    this.componentManagerStore[manager.fullPath] = manager;
	    manager.enhanceComponentInstance(registerComponentManager.bind(this), deRegisterComponentManager.bind(this));
	    this.appContainer.namespaceRegistry.registerComponentManager(manager);
	    return manager;
	  };

	  _proto.deregister = function deregister(componentInstance) {
	    var cm = componentInstance[COMPONENT_MANAGER_LOCAL_KEY];
	    if (!cm) return;
	    deRegisterComponentManager.call(this, cm);
	  };

	  _proto.destroy = function destroy() {
	    Object.values(this.componentManagerStore).map(function (cm) {
	      return cm.destroy();
	    });
	  };

	  return ComponentRegistry;
	}();

	function registerComponentManager(cm) {
	  if (cm.options.reducer && func(cm.options.reducer)) {
	    this.appContainer.reducerRegistry.register(cm.options.reducer.bind(cm.componentInstance), {
	      initState: cm.initState,
	      path: cm.fullPath,
	      namespace: cm.namespace,
	      persistState: cm.persistState,
	      allowedIncomingMulticastActionTypes: cm.allowedIncomingMulticastActionTypes
	    });
	  }

	  if (cm.options.saga && func(cm.options.saga)) {
	    this.appContainer.sagaRegistry.register(cm.options.saga.bind(cm.componentInstance), {
	      path: cm.fullPath,
	      namespace: cm.namespace,
	      allowedIncomingMulticastActionTypes: cm.allowedIncomingMulticastActionTypes
	    });
	  }
	}

	function deRegisterComponentManager(cm) {
	  if (cm.options.reducer && func(cm.options.reducer)) {
	    this.appContainer.sagaRegistry.deregister(cm.fullPath);
	  }

	  if (cm.options.saga && func(cm.options.saga)) {
	    this.appContainer.reducerRegistry.deregister(cm.fullPath);
	  }

	  this.appContainer.namespaceRegistry.deregisterComponentManager(cm);
	}

	var INIT_STATE =
	/*#__PURE__*/
	Symbol("@@" +
	/*#__PURE__*/
	getPackageName() + "/INIT_STATE");
	var EMPTY_STATE =
	/*#__PURE__*/
	Symbol("@@" +
	/*#__PURE__*/
	getPackageName() + "/EMPTY_STATE");

	var actionTypes = /*#__PURE__*/Object.freeze({
		INIT_STATE: INIT_STATE,
		EMPTY_STATE: EMPTY_STATE
	});

	var namespace = "io.github.t83714/" +
	/*#__PURE__*/
	getPackageName() + "/ReducerRegistry";

	var initState = function initState(path, data, persistState) {
	  return {
	    type: INIT_STATE,
	    namespace: namespace,
	    payload: {
	      path: path,
	      data: data,
	      persistState: persistState
	    }
	  };
	};
	var emptyState = function emptyState(path, data) {
	  return {
	    type: EMPTY_STATE,
	    namespace: namespace,
	    payload: {
	      path: path,
	      data: data
	    }
	  };
	};

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */

	var isobject = function isObject(val) {
	  return val != null && typeof val === 'object' && Array.isArray(val) === false;
	};

	function isObjectObject(o) {
	  return isobject(o) === true
	    && Object.prototype.toString.call(o) === '[object Object]';
	}

	var isPlainObject$1 = function isPlainObject(o) {
	  var ctor,prot;

	  if (isObjectObject(o) === false) return false;

	  // If has modified constructor
	  ctor = o.constructor;
	  if (typeof ctor !== 'function') return false;

	  // If has modified prototype
	  prot = ctor.prototype;
	  if (isObjectObject(prot) === false) return false;

	  // If constructor does not have an Object-specific method
	  if (prot.hasOwnProperty('isPrototypeOf') === false) {
	    return false;
	  }

	  // Most likely a plain Object
	  return true;
	};

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function isEmpty (value) {
	  if (isNumber(value)) {
	    return false
	  }
	  if (!value) {
	    return true
	  }
	  if (isArray(value) && value.length === 0) {
	    return true
	  } else if (!isString(value)) {
	    for (var i in value) {
	      if (_hasOwnProperty.call(value, i)) {
	        return false
	      }
	    }
	    return true
	  }
	  return false
	}

	function isNumber (value) {
	  return typeof value === 'number'
	}

	function isString (obj) {
	  return typeof obj === 'string'
	}

	function isArray (obj) {
	  return Array.isArray(obj)
	}

	function assignToObj (target, source) {
	  for (var key in source) {
	    if (_hasOwnProperty.call(source, key)) {
	      target[key] = source[key];
	    }
	  }
	  return target
	}

	function getKey (key) {
	  var intKey = parseInt(key);
	  if (intKey.toString() === key) {
	    return intKey
	  }
	  return key
	}

	var objectPathImmutable = function (src) {
	  var dest = src;
	  var committed = false;

	  var transaction = Object.keys(api).reduce(function (proxy, prop) {
	    /* istanbul ignore else */
	    if (typeof api[prop] === 'function') {
	      proxy[prop] = function () {
	        var args = [dest, src].concat(Array.prototype.slice.call(arguments));

	        if (committed) {
	          throw new Error('Cannot call ' + prop + ' after `value`')
	        }

	        dest = api[prop].apply(null, args);

	        return transaction
	      };
	    }

	    return proxy
	  }, {});

	  transaction.value = function () {
	    committed = true;
	    return dest
	  };

	  return transaction
	};

	function clone (obj, createIfEmpty, assumeArray) {
	  if (obj == null) {
	    if (createIfEmpty) {
	      if (assumeArray) {
	        return []
	      }

	      return {}
	    }

	    return obj
	  } else if (isArray(obj)) {
	    return obj.slice()
	  }

	  return assignToObj({}, obj)
	}

	function deepMerge (dest, src) {
	  if (dest !== src && isPlainObject$1(dest) && isPlainObject$1(src)) {
	    var merged = {};
	    for (var key in dest) {
	      if (dest.hasOwnProperty(key)) {
	        if (src.hasOwnProperty(key)) {
	          merged[key] = deepMerge(dest[key], src[key]);
	        } else {
	          merged[key] = dest[key];
	        }
	      }
	    }

	    for (key in src) {
	      if (src.hasOwnProperty(key)) {
	        merged[key] = deepMerge(dest[key], src[key]);
	      }
	    }
	    return merged
	  }
	  return src
	}

	function changeImmutable (dest, src, path, changeCallback) {
	  if (isNumber(path)) {
	    path = [path];
	  }
	  if (isEmpty(path)) {
	    return src
	  }
	  if (isString(path)) {
	    return changeImmutable(dest, src, path.split('.').map(getKey), changeCallback)
	  }
	  var currentPath = path[0];

	  if (!dest || dest === src) {
	    dest = clone(src, true, isNumber(currentPath));
	  }

	  if (path.length === 1) {
	    return changeCallback(dest, currentPath)
	  }

	  if (src != null) {
	    src = src[currentPath];
	  }

	  dest[currentPath] = changeImmutable(dest[currentPath], src, path.slice(1), changeCallback);

	  return dest
	}

	var api = {};
	api.set = function set (dest, src, path, value) {
	  if (isEmpty(path)) {
	    return value
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    clonedObj[finalPath] = value;
	    return clonedObj
	  })
	};

	api.update = function update (dest, src, path, updater) {
	  if (isEmpty(path)) {
	    return updater(clone(src))
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    clonedObj[finalPath] = updater(clonedObj[finalPath]);
	    return clonedObj
	  })
	};

	api.push = function push (dest, src, path /*, values */) {
	  var values = Array.prototype.slice.call(arguments, 3);
	  if (isEmpty(path)) {
	    if (!isArray(src)) {
	      return values
	    } else {
	      return src.concat(values)
	    }
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    if (!isArray(clonedObj[finalPath])) {
	      clonedObj[finalPath] = values;
	    } else {
	      clonedObj[finalPath] = clonedObj[finalPath].concat(values);
	    }
	    return clonedObj
	  })
	};

	api.insert = function insert (dest, src, path, value, at) {
	  at = ~~at;
	  if (isEmpty(path)) {
	    if (!isArray(src)) {
	      return [value]
	    }

	    var first = src.slice(0, at);
	    first.push(value);
	    return first.concat(src.slice(at))
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    var arr = clonedObj[finalPath];
	    if (!isArray(arr)) {
	      if (arr != null && typeof arr !== 'undefined') {
	        throw new Error('Expected ' + path + 'to be an array. Instead got ' + typeof path)
	      }
	      arr = [];
	    }

	    var first = arr.slice(0, at);
	    first.push(value);
	    clonedObj[finalPath] = first.concat(arr.slice(at));
	    return clonedObj
	  })
	};

	api.del = function del (dest, src, path) {
	  if (isEmpty(path)) {
	    return void 0
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    if (Array.isArray(clonedObj)) {
	      if (clonedObj[finalPath] !== undefined) {
	        clonedObj.splice(finalPath, 1);
	      }
	    } else {
	      if (clonedObj.hasOwnProperty(finalPath)) {
	        delete clonedObj[finalPath];
	      }
	    }
	    return clonedObj
	  })
	};

	api.assign = function assign (dest, src, path, source) {
	  if (isEmpty(path)) {
	    if (isEmpty(source)) {
	      return src
	    }
	    return assignToObj(clone(src), source)
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    source = Object(source);
	    var target = clone(clonedObj[finalPath], true);
	    assignToObj(target, source);

	    clonedObj[finalPath] = target;
	    return clonedObj
	  })
	};

	api.merge = function assign (dest, src, path, source) {
	  if (isEmpty(path)) {
	    if (isEmpty(source)) {
	      return src
	    }
	    return deepMerge(src, source)
	  }
	  return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
	    source = Object(source);
	    clonedObj[finalPath] = deepMerge(clonedObj[finalPath], source);
	    return clonedObj
	  })
	};

	var objectPathImmutable_1 = Object.keys(api).reduce(function (objectPathImmutable, method) {
	  objectPathImmutable[method] = api[method].bind(null, null);

	  return objectPathImmutable
	}, objectPathImmutable);

	var defaultReducerOptions = {
	  initState: {},
	  persistState: true
	};
	/**
	 * This function should NOT return a new state copy
	 */

	function processInitState(state, action$$1) {
	  var _action$payload = action$$1.payload,
	      data = _action$payload.data,
	      persistState = _action$payload.persistState,
	      path = _action$payload.path;
	  var pathItems = path.split("/");
	  var doNotReplace = persistState;
	  var hasData = objectPath.has(state, pathItems);

	  if (hasData) {
	    if (doNotReplace) {
	      // --- has initialised
	      // --- force component.state to refresh
	      var existingData = objectPath.get(state, pathItems);
	      return objectPathImmutable_1.assign(state, pathItems, existingData);
	    }
	  }

	  return objectPathImmutable_1.assign(state, pathItems, data);
	}
	/**
	 * This function should NOT return a new state copy
	 */


	function processEmptyState(state, action$$1) {
	  var _action$payload2 = action$$1.payload,
	      path = _action$payload2.path,
	      data = _action$payload2.data;
	  var pathItems = path.split("/");
	  return objectPathImmutable_1.update(state, pathItems, function (targetState) {
	    Object.keys(data).forEach(function (key) {
	      delete targetState[key];
	    });
	    return targetState;
	  });
	}

	function processNamespacedAction(state, action$$1) {
	  var _this = this;

	  if (!namespacedAction(action$$1)) return state;
	  var matchedPaths = this.pathRegistry.searchDispatchPaths(action$$1);
	  if (!matchedPaths || !matchedPaths.length) return state;
	  var newState = state;
	  matchedPaths.forEach(function (p) {
	    var reducer = _this.reducerStore[p].reducer;
	    if (!reducer || typeof reducer !== "function") return;
	    var pathItems = p.split("/");
	    var componentState = objectPath.get(state, pathItems);
	    var newComponentState = reducer(componentState, action$$1);

	    if (componentState === newComponentState) {
	      //--- skip update when no changes; likely not interested action
	      return;
	    } else {
	      newState = objectPathImmutable_1.assign(newState, pathItems, newComponentState);
	    }
	  });
	  return newState;
	}

	function globalReducer(externalGlobalReducer, state, action$$1) {
	  if (!action(action$$1)) return state;
	  var newState = state;

	  switch (action$$1.type) {
	    case INIT_STATE:
	      newState = processInitState(newState, action$$1);
	      break;

	    case EMPTY_STATE:
	      newState = processEmptyState(newState, action$$1);
	      break;
	  }

	  newState = processNamespacedAction.call(this, newState, action$$1);

	  if (externalGlobalReducer && typeof externalGlobalReducer === "function") {
	    newState = externalGlobalReducer(newState, action$$1);
	  }

	  return newState;
	}

	var ReducerRegistry =
	/*#__PURE__*/
	function () {
	  function ReducerRegistry(appContainer) {
	    this.appContainer = appContainer;
	    this.reducerStore = {};
	    this.pathRegistry = new PathRegistry(true);
	    this.appContainer.actionRegistry.register(namespace, actionTypes);
	  }

	  var _proto = ReducerRegistry.prototype;

	  _proto.destroy = function destroy() {
	    this.pathRegistry.destroy();
	    this.appContainer = null;
	  };

	  _proto.createGlobalReducer = function createGlobalReducer(externalGlobalReducer) {
	    if (externalGlobalReducer === void 0) {
	      externalGlobalReducer = null;
	    }

	    return globalReducer.bind(this, externalGlobalReducer);
	  };

	  _proto.register = function register(reducer, reducerOptions) {
	    if (!reducer || typeof reducer !== "function") throw new Error("Failed to register reducer: invalid reducer parameter.");
	    if (!reducerOptions) reducerOptions = _extends_1({}, defaultReducerOptions);
	    var _reducerOptions = reducerOptions,
	        path = _reducerOptions.path,
	        namespace$$1 = _reducerOptions.namespace,
	        initState$$1 = _reducerOptions.initState,
	        persistState = _reducerOptions.persistState,
	        allowedIncomingMulticastActionTypes = _reducerOptions.allowedIncomingMulticastActionTypes;
	    if (!path) throw new Error("Failed to register namespaced reducer: namespace path cannot be empty!");
	    var registeredPath = normalize(path);
	    var localPathPos = namespace$$1 ? registeredPath.lastIndexOf(namespace$$1) : registeredPath.length;

	    if (this.pathRegistry.add(registeredPath, {
	      localPathPos: localPathPos,
	      namespace: namespace$$1,
	      allowedIncomingMulticastActionTypes: allowedIncomingMulticastActionTypes
	    }) === null) {
	      throw new Error("Failed to register namespaced reducer: given path `" + registeredPath + "` has been registered.");
	    }

	    this.reducerStore[registeredPath] = _extends_1({}, reducerOptions, {
	      reducer: reducer,
	      initState: initState$$1,
	      persistState: persistState,
	      allowedIncomingMulticastActionTypes: allowedIncomingMulticastActionTypes,
	      path: registeredPath
	    });
	    setInitState.call(this, registeredPath, initState$$1, persistState);
	  };

	  _proto.deregister = function deregister(path) {
	    var normalizedPath = normalize(path);
	    this.pathRegistry.remove(normalizedPath);
	    var reduceItem = this.reducerStore[normalizedPath];
	    if (!reduceItem) return;
	    delete this.reducerStore[normalizedPath];
	    var persistState = reduceItem.persistState,
	        initState$$1 = reduceItem.initState;
	    if (persistState) return;
	    emptyInitState.call(this, normalizedPath, initState$$1);
	  };

	  return ReducerRegistry;
	}();

	function setInitState(path, initState$$1, persistState) {
	  if (!this.appContainer.store) throw new Error("Failed to set init state for component reducer: redux store not available yet!");
	  this.appContainer.store.dispatch(initState(path, initState$$1, persistState));
	}

	function emptyInitState(path, initState$$1) {
	  if (!this.appContainer.store) throw new Error("Failed to set init state for component reducer: redux store not available yet!");
	  this.appContainer.store.dispatch(emptyState(path, initState$$1));
	}

	var runtime = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	!(function(global) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = module.exports;

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // In sloppy mode, unbound `this` refers to the global object, fallback to
	  // Function constructor if we're in global strict mode. That is sadly a form
	  // of indirect eval which violates Content Security Policy.
	  (function() {
	    return this || (typeof self === "object" && self);
	  })() || Function("return this")()
	);
	});

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g = (function() {
	  return this || (typeof self === "object" && self);
	})() || Function("return this")();

	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;

	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;

	var runtimeModule = runtime;

	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}

	var regenerator = runtimeModule;

	var INIT_SAGA =
	/*#__PURE__*/
	Symbol("@@" +
	/*#__PURE__*/
	getPackageName() + "/INIT_SAGA");
	var CANCEL_SAGA =
	/*#__PURE__*/
	Symbol("@@" +
	/*#__PURE__*/
	getPackageName() + "/CANCEL_SAGA");

	var actionTypes$1 = /*#__PURE__*/Object.freeze({
		INIT_SAGA: INIT_SAGA,
		CANCEL_SAGA: CANCEL_SAGA
	});

	var namespace$1 = "io.github.t83714/" +
	/*#__PURE__*/
	getPackageName() + "/SagaRegistry";

	var initSaga = function initSaga(sagaItem) {
	  return {
	    type: INIT_SAGA,
	    namespace: namespace$1,
	    payload: sagaItem
	  };
	};
	var cancelSaga = function cancelSaga(pathOrTask) {
	  return {
	    type: CANCEL_SAGA,
	    namespace: namespace$1,
	    payload: pathOrTask
	  };
	};

	var EventChannel =
	/*#__PURE__*/
	function () {
	  function EventChannel(buffer$$1) {
	    if (buffer$$1 === void 0) {
	      buffer$$1 = null;
	    }

	    if (!buffer$$1) {
	      this.buffer = createSagaMiddleware.buffers.expanding();
	    } else {
	      this.buffer = buffer$$1;
	    }

	    this.eventEmitters = [];
	  }

	  var _proto = EventChannel.prototype;

	  _proto.subscribe = function subscribe(emitter) {
	    this.unsubscribe(emitter);
	    this.eventEmitters.push(emitter);
	  };

	  _proto.unsubscribe = function unsubscribe(emitter) {
	    this.eventEmitters = this.eventEmitters.filter(function (item) {
	      return item !== emitter;
	    });
	  };

	  _proto.dispatch = function dispatch(event) {
	    this.eventEmitters.forEach(function (emitter) {
	      return emitter(event);
	    });
	  };

	  _proto.destroy = function destroy() {
	    this.eventEmitters = [];
	  };

	  _proto.create = function create(matcher) {
	    var _this = this;

	    return createSagaMiddleware.eventChannel(function (emitter) {
	      _this.subscribe(emitter);

	      return function () {
	        _this.unsubscribe(emitter);
	      };
	    }, this.buffer, matcher ? matcher : kTrue);
	  };

	  return EventChannel;
	}();

	function take(sagaItem, pattern$$1) {
	  if (!pattern$$1) throw new Error("effects.take: pattern parameter cannot be empty!");
	  var chan = sagaItem.chan;
	  return rsEffects.take(chan, pattern$$1);
	}
	function takeMaybe(sagaItem, pattern$$1) {
	  if (!pattern$$1) throw new Error("effects.take: pattern parameter cannot be empty!");
	  var chan = sagaItem.chan;
	  return rsEffects.takeMaybe(chan, pattern$$1);
	}
	function put(sagaItem, action$$1, relativeDispatchPath) {
	  if (relativeDispatchPath === void 0) {
	    relativeDispatchPath = "";
	  }

	  var path = sagaItem.path;
	  var pc = new PathContext(path);
	  var namespacedAction$$1 = pc.convertNamespacedAction(action$$1, relativeDispatchPath); // --- query action Type's original namespace so that it can be serialised correctly if needed

	  var namespace = this.appContainer.actionRegistry.findNamespaceByActionType(namespacedAction$$1.type);

	  if (!namespace) {
	    log("Cannot locate namespace for Action `" + symbolToString(namespacedAction$$1.type) + "`: `" + symbolToString(namespacedAction$$1.type) + "` needs to be registered otherwise the action won't be serializable.");
	  } else {
	    namespacedAction$$1.namespace = namespace;
	  }

	  return rsEffects.put(namespacedAction$$1);
	}
	function select(sagaItem, selector) {
	  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }

	  var path = sagaItem.path;
	  var pathItems = path.split("/");
	  return rsEffects.select(function (state) {
	    var namespacedState = objectPath.get(state, pathItems);

	    if (selector && func(selector)) {
	      return selector.apply(void 0, [namespacedState].concat(args));
	    }

	    return namespacedState;
	  });
	}
	var takeEvery = function takeEvery(sagaItem, pattern$$1, saga) {
	  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
	    args[_key2 - 3] = arguments[_key2];
	  }

	  return rsEffects.fork(
	  /*#__PURE__*/
	  regenerator.mark(function _callee() {
	    var action$$1;
	    return regenerator.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:

	            _context.next = 3;
	            return take(sagaItem, pattern$$1);

	          case 3:
	            action$$1 = _context.sent;
	            _context.next = 6;
	            return rsEffects.fork.apply(void 0, [saga].concat(args.concat(action$$1)));

	          case 6:
	            _context.next = 0;
	            break;

	          case 8:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	};
	var takeLatest = function takeLatest(sagaItem, pattern$$1, saga) {
	  for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	    args[_key3 - 3] = arguments[_key3];
	  }

	  return rsEffects.fork(
	  /*#__PURE__*/
	  regenerator.mark(function _callee2() {
	    var lastTask, action$$1;
	    return regenerator.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:

	            _context2.next = 3;
	            return take(sagaItem, pattern$$1);

	          case 3:
	            action$$1 = _context2.sent;

	            if (!lastTask) {
	              _context2.next = 7;
	              break;
	            }

	            _context2.next = 7;
	            return rsEffects.cancel(lastTask);

	          case 7:
	            _context2.next = 9;
	            return rsEffects.fork.apply(void 0, [saga].concat(args.concat(action$$1)));

	          case 9:
	            lastTask = _context2.sent;
	            _context2.next = 0;
	            break;

	          case 12:
	          case "end":
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	};
	var takeLeading = function takeLeading(sagaItem, pattern$$1, saga) {
	  for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
	    args[_key4 - 3] = arguments[_key4];
	  }

	  return rsEffects.fork(
	  /*#__PURE__*/
	  regenerator.mark(function _callee3() {
	    var action$$1;
	    return regenerator.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:

	            _context3.next = 3;
	            return take(sagaItem, pattern$$1);

	          case 3:
	            action$$1 = _context3.sent;
	            _context3.next = 6;
	            return rsEffects.call.apply(void 0, [saga].concat(args.concat(action$$1)));

	          case 6:
	            _context3.next = 0;
	            break;

	          case 8:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	};
	var throttle = function throttle(sagaItem, ms, pattern$$1, task) {
	  for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {
	    args[_key5 - 4] = arguments[_key5];
	  }

	  return rsEffects.fork(
	  /*#__PURE__*/
	  regenerator.mark(function _callee5() {
	    var throttleChannel, action$$1;
	    return regenerator.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return rsEffects.call(createSagaMiddleware.channel, createSagaMiddleware.buffers.sliding(1));

	          case 2:
	            throttleChannel = _context5.sent;
	            _context5.next = 5;
	            return takeEvery(sagaItem, pattern$$1,
	            /*#__PURE__*/
	            regenerator.mark(function _callee4(action$$1) {
	              return regenerator.wrap(function _callee4$(_context4) {
	                while (1) {
	                  switch (_context4.prev = _context4.next) {
	                    case 0:
	                      _context4.next = 2;
	                      return rsEffects.put(throttleChannel, action$$1);

	                    case 2:
	                    case "end":
	                      return _context4.stop();
	                  }
	                }
	              }, _callee4, this);
	            }));

	          case 5:

	            _context5.next = 8;
	            return rsEffects.take(throttleChannel);

	          case 8:
	            action$$1 = _context5.sent;
	            _context5.next = 11;
	            return rsEffects.fork.apply(void 0, [task].concat(args, [action$$1]));

	          case 11:
	            _context5.next = 13;
	            return rsEffects.delay(ms);

	          case 13:
	            _context5.next = 5;
	            break;

	          case 15:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this);
	  }));
	};
	var debounce = function debounce(sagaItem, ms, pattern$$1, task) {
	  for (var _len6 = arguments.length, args = new Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {
	    args[_key6 - 4] = arguments[_key6];
	  }

	  return rsEffects.fork(
	  /*#__PURE__*/
	  regenerator.mark(function _callee6() {
	    var action$$1, _ref, debounced, _action;

	    return regenerator.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:

	            _context6.next = 3;
	            return take(sagaItem, pattern$$1);

	          case 3:
	            action$$1 = _context6.sent;

	          case 4:

	            _context6.next = 7;
	            return rsEffects.race({
	              debounced: rsEffects.delay(ms),
	              _action: take(sagaItem, pattern$$1)
	            });

	          case 7:
	            _ref = _context6.sent;
	            debounced = _ref.debounced;
	            _action = _ref._action;

	            if (!debounced) {
	              _context6.next = 14;
	              break;
	            }

	            _context6.next = 13;
	            return rsEffects.fork.apply(void 0, [task].concat(args, [action$$1]));

	          case 13:
	            return _context6.abrupt("break", 17);

	          case 14:
	            action$$1 = _action;
	            _context6.next = 4;
	            break;

	          case 17:
	            _context6.next = 0;
	            break;

	          case 19:
	          case "end":
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this);
	  }));
	};
	var actionChannel = function actionChannel(sagaItem, pattern$$1, buffer$$1) {
	  return rsEffects.call(
	  /*#__PURE__*/
	  regenerator.mark(function _callee8() {
	    var chan, bufferChan;
	    return regenerator.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            chan = sagaItem.chan;
	            _context8.next = 3;
	            return rsEffects.call(createSagaMiddleware.channel, buffer$$1);

	          case 3:
	            bufferChan = _context8.sent;
	            _context8.prev = 4;
	            _context8.next = 7;
	            return rsEffects.fork(
	            /*#__PURE__*/
	            regenerator.mark(function _callee7() {
	              var action$$1;
	              return regenerator.wrap(function _callee7$(_context7) {
	                while (1) {
	                  switch (_context7.prev = _context7.next) {
	                    case 0:

	                      _context7.next = 3;
	                      return take(chan, pattern$$1);

	                    case 3:
	                      action$$1 = _context7.sent;
	                      _context7.next = 6;
	                      return put(bufferChan, action$$1);

	                    case 6:
	                      _context7.next = 0;
	                      break;

	                    case 8:
	                    case "end":
	                      return _context7.stop();
	                  }
	                }
	              }, _callee7, this);
	            }));

	          case 7:
	            _context8.prev = 7;
	            if (bufferChan) bufferChan.close();
	            return _context8.finish(7);

	          case 10:
	            return _context8.abrupt("return", bufferChan);

	          case 11:
	          case "end":
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this, [[4,, 7, 10]]);
	  }));
	};

	var namespacedEffects = /*#__PURE__*/Object.freeze({
		take: take,
		takeMaybe: takeMaybe,
		put: put,
		select: select,
		takeEvery: takeEvery,
		takeLatest: takeLatest,
		takeLeading: takeLeading,
		throttle: throttle,
		debounce: debounce,
		actionChannel: actionChannel
	});

	var createEffects = function createEffects(thisObj, SagaItem) {
	  var effectCreators = {};
	  Object.keys(namespacedEffects).forEach(function (idx) {
	    effectCreators[idx] = namespacedEffects[idx].bind(thisObj, SagaItem);
	  });
	  Object.keys(rsEffects).forEach(function (idx) {
	    if (undef(effectCreators[idx])) {
	      effectCreators[idx] = func(rsEffects[idx]) ? rsEffects[idx].bind(thisObj) : rsEffects[idx];
	    }
	  });
	  return effectCreators;
	};

	var _marked =
	/*#__PURE__*/
	regenerator.mark(hostSaga),
	    _marked2 =
	/*#__PURE__*/
	regenerator.mark(startCommandChan),
	    _marked3 =
	/*#__PURE__*/
	regenerator.mark(processCommandAction),
	    _marked4 =
	/*#__PURE__*/
	regenerator.mark(initSaga$1),
	    _marked5 =
	/*#__PURE__*/
	regenerator.mark(initGlobalSaga),
	    _marked6 =
	/*#__PURE__*/
	regenerator.mark(cancelSaga$1);

	function hostSaga() {
	  return regenerator.wrap(function hostSaga$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return rsEffects.fork([this, startCommandChan]);

	        case 2:
	          _context.next = 4;
	          return rsEffects.fork([this, forwardNamespacedAction]);

	        case 4:
	        case "end":
	          return _context.stop();
	      }
	    }
	  }, _marked, this);
	}

	var forwardNamespacedAction =
	/*#__PURE__*/
	regenerator.mark(function forwardNamespacedAction() {
	  return regenerator.wrap(function forwardNamespacedAction$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          _context3.next = 2;
	          return rsEffects.takeEvery(function (action$$1) {
	            return namespacedAction(action$$1);
	          },
	          /*#__PURE__*/
	          regenerator.mark(function _callee(action$$1) {
	            var matchedPaths, i, sagaItem;
	            return regenerator.wrap(function _callee$(_context2) {
	              while (1) {
	                switch (_context2.prev = _context2.next) {
	                  case 0:
	                    matchedPaths = this.pathRegistry.searchDispatchPaths(action$$1);

	                    if (!(!matchedPaths || !matchedPaths.length)) {
	                      _context2.next = 3;
	                      break;
	                    }

	                    return _context2.abrupt("return");

	                  case 3:
	                    i = 0;

	                  case 4:
	                    if (!(i < matchedPaths.length)) {
	                      _context2.next = 13;
	                      break;
	                    }

	                    sagaItem = this.namespacedSagaItemStore[matchedPaths[i]];

	                    if (!(!sagaItem || !sagaItem.chan)) {
	                      _context2.next = 8;
	                      break;
	                    }

	                    return _context2.abrupt("continue", 10);

	                  case 8:
	                    _context2.next = 10;
	                    return rsEffects.put(sagaItem.chan, action$$1);

	                  case 10:
	                    i++;
	                    _context2.next = 4;
	                    break;

	                  case 13:
	                  case "end":
	                    return _context2.stop();
	                }
	              }
	            }, _callee, this);
	          }).bind(this));

	        case 2:
	        case "end":
	          return _context3.stop();
	      }
	    }
	  }, forwardNamespacedAction, this);
	});

	function startCommandChan() {
	  var commandChan, action$$1;
	  return regenerator.wrap(function startCommandChan$(_context4) {
	    while (1) {
	      switch (_context4.prev = _context4.next) {
	        case 0:
	          _context4.prev = 0;
	          _context4.next = 3;
	          return rsEffects.call([this.hostSagaCommandChan, this.hostSagaCommandChan.create]);

	        case 3:
	          commandChan = _context4.sent;

	        case 4:

	          _context4.next = 7;
	          return rsEffects.take(commandChan);

	        case 7:
	          action$$1 = _context4.sent;
	          _context4.next = 10;
	          return rsEffects.fork([this, processCommandAction], action$$1);

	        case 10:
	          _context4.next = 4;
	          break;

	        case 12:
	          _context4.prev = 12;
	          _context4.next = 15;
	          return rsEffects.cancelled();

	        case 15:
	          if (!_context4.sent) {
	            _context4.next = 17;
	            break;
	          }

	          commandChan.close();

	        case 17:
	          return _context4.finish(12);

	        case 18:
	        case "end":
	          return _context4.stop();
	      }
	    }
	  }, _marked2, this, [[0,, 12, 18]]);
	}

	function processCommandAction(_ref) {
	  var type, payload;
	  return regenerator.wrap(function processCommandAction$(_context5) {
	    while (1) {
	      switch (_context5.prev = _context5.next) {
	        case 0:
	          type = _ref.type, payload = _ref.payload;
	          _context5.t0 = type;
	          _context5.next = _context5.t0 === INIT_SAGA ? 4 : _context5.t0 === CANCEL_SAGA ? 7 : 10;
	          break;

	        case 4:
	          _context5.next = 6;
	          return rsEffects.call([this, initSaga$1], payload);

	        case 6:
	          return _context5.abrupt("break", 11);

	        case 7:
	          _context5.next = 9;
	          return rsEffects.call([this, cancelSaga$1], payload);

	        case 9:
	          return _context5.abrupt("break", 11);

	        case 10:
	          throw new Error("Unknown host command action: " + type);

	        case 11:
	        case "end":
	          return _context5.stop();
	      }
	    }
	  }, _marked3, this);
	}

	function initSaga$1(sagaItem) {
	  var saga, path, namespace, allowedIncomingMulticastActionTypes, registeredPath, localPathPos, chan, newSagaItem, effects, task, registerSagaItem;
	  return regenerator.wrap(function initSaga$(_context7) {
	    while (1) {
	      switch (_context7.prev = _context7.next) {
	        case 0:
	          saga = sagaItem.saga, path = sagaItem.path, namespace = sagaItem.namespace, allowedIncomingMulticastActionTypes = sagaItem.allowedIncomingMulticastActionTypes;
	          registeredPath = normalize(path);

	          if (registeredPath) {
	            _context7.next = 6;
	            break;
	          }

	          _context7.next = 5;
	          return rsEffects.call([this, initGlobalSaga], saga);

	        case 5:
	          return _context7.abrupt("return");

	        case 6:
	          localPathPos = namespace ? registeredPath.lastIndexOf(namespace) : registeredPath.length;

	          if (!(this.pathRegistry.add(registeredPath, {
	            localPathPos: localPathPos,
	            namespace: namespace,
	            allowedIncomingMulticastActionTypes: allowedIncomingMulticastActionTypes
	          }) === null)) {
	            _context7.next = 9;
	            break;
	          }

	          throw new Error("Failed to register namespaced saga: given path `" + registeredPath + "` has been registered.");

	        case 9:
	          _context7.next = 11;
	          return rsEffects.call(createSagaMiddleware.multicastChannel);

	        case 11:
	          chan = _context7.sent;
	          newSagaItem = _extends_1({}, sagaItem, {
	            chan: chan,
	            path: registeredPath,
	            allowedIncomingMulticastActionTypes: allowedIncomingMulticastActionTypes
	          });
	          effects = createEffects(this, newSagaItem);
	          _context7.next = 16;
	          return rsEffects.fork(
	          /*#__PURE__*/
	          regenerator.mark(function _callee2() {
	            return regenerator.wrap(function _callee2$(_context6) {
	              while (1) {
	                switch (_context6.prev = _context6.next) {
	                  case 0:
	                    _context6.prev = 0;
	                    _context6.next = 3;
	                    return rsEffects.call(saga, effects);

	                  case 3:
	                    _context6.next = 8;
	                    break;

	                  case 5:
	                    _context6.prev = 5;
	                    _context6.t0 = _context6["catch"](0);
	                    log("Error thrown from saga registered at `" + registeredPath + "`: ", "error", _context6.t0);

	                  case 8:
	                  case "end":
	                    return _context6.stop();
	                }
	              }
	            }, _callee2, this, [[0, 5]]);
	          }));

	        case 16:
	          task = _context7.sent;
	          registerSagaItem = _extends_1({}, newSagaItem, {
	            task: task
	          });
	          this.namespacedSagaItemStore[registeredPath] = registerSagaItem;

	        case 19:
	        case "end":
	          return _context7.stop();
	      }
	    }
	  }, _marked4, this);
	}

	function initGlobalSaga(saga) {
	  var task;
	  return regenerator.wrap(function initGlobalSaga$(_context9) {
	    while (1) {
	      switch (_context9.prev = _context9.next) {
	        case 0:
	          _context9.next = 2;
	          return rsEffects.fork(
	          /*#__PURE__*/
	          regenerator.mark(function _callee3() {
	            return regenerator.wrap(function _callee3$(_context8) {
	              while (1) {
	                switch (_context8.prev = _context8.next) {
	                  case 0:
	                    _context8.prev = 0;
	                    _context8.next = 3;
	                    return rsEffects.call(saga);

	                  case 3:
	                    _context8.next = 8;
	                    break;

	                  case 5:
	                    _context8.prev = 5;
	                    _context8.t0 = _context8["catch"](0);
	                    log("Error thrown from registered global saga: ", "error", _context8.t0);

	                  case 8:
	                  case "end":
	                    return _context8.stop();
	                }
	              }
	            }, _callee3, this, [[0, 5]]);
	          }));

	        case 2:
	          task = _context9.sent;
	          this.globalSagaTaskList.push(task);

	        case 4:
	        case "end":
	          return _context9.stop();
	      }
	    }
	  }, _marked5, this);
	}

	function cancelSaga$1(pathOrTask) {
	  var _this = this;

	  var path, sagaItem;
	  return regenerator.wrap(function cancelSaga$(_context10) {
	    while (1) {
	      switch (_context10.prev = _context10.next) {
	        case 0:
	          if (!(typeof pathOrTask === "string")) {
	            _context10.next = 12;
	            break;
	          }

	          path = normalize(pathOrTask);
	          this.pathRegistry.remove(path);
	          sagaItem = this.namespacedSagaItemStore[path];

	          if (sagaItem) {
	            _context10.next = 6;
	            break;
	          }

	          return _context10.abrupt("return");

	        case 6:
	          delete this.namespacedSagaItemStore[path];
	          sagaItem.chan.close();
	          _context10.next = 10;
	          return rsEffects.cancel(sagaItem.task);

	        case 10:
	          _context10.next = 16;
	          break;

	        case 12:
	          Object.keys(this.namespacedSagaItemStore).forEach(function (idx) {
	            if (_this.namespacedSagaItemStore[idx].task === pathOrTask) {
	              delete _this.namespacedSagaItemStore[idx];
	            }
	          });
	          this.globalSagaTaskList = this.globalSagaTaskList.filter(function (s) {
	            return s !== pathOrTask;
	          });
	          _context10.next = 16;
	          return rsEffects.cancel(pathOrTask);

	        case 16:
	        case "end":
	          return _context10.stop();
	      }
	    }
	  }, _marked6, this);
	}

	var SagaRegistry =
	/*#__PURE__*/
	function () {
	  function SagaRegistry(appContainer) {
	    this.appContainer = appContainer;
	    this.namespacedSagaItemStore = {};
	    this.globalSagaTaskList = [];
	    this.pathRegistry = new PathRegistry(true);
	    this.hostSagaCommandChan = new EventChannel(createSagaMiddleware.buffers.expanding());
	    this.appContainer.actionRegistry.register(namespace$1, actionTypes$1);
	  }

	  var _proto = SagaRegistry.prototype;

	  _proto.createHostSaga = function createHostSaga() {
	    return hostSaga.bind(this);
	  };

	  _proto.register = function register(saga, sagaOptions) {
	    if (!saga || typeof saga !== "function") throw new Error("SagaRegistry::register: saga parameter cannot be empty!");

	    var sagaItem = _extends_1({
	      saga: saga
	    }, object(sagaOptions) ? sagaOptions : {});

	    this.hostSagaCommandChan.dispatch(initSaga(sagaItem));
	  };

	  _proto.deregister = function deregister(pathOrTask) {
	    if (!pathOrTask) throw new Error("SagaRegistry::deregister: pathOrTask parameter cannot be empty!");
	    this.hostSagaCommandChan.dispatch(cancelSaga(pathOrTask));
	  };

	  _proto.destroy = function destroy() {
	    this.hostSagaCommandChan.destroy();
	    this.appContainer = null;
	    this.globalSagaTaskList = [];
	    this.pathRegistry.destroy();
	  };

	  return SagaRegistry;
	}();

	var SagaMonitorRegistry =
	/*#__PURE__*/
	function () {
	  function SagaMonitorRegistry() {
	    this.effectTriggered = [];
	    this.effectResolved = [];
	    this.effectRejected = [];
	    this.effectCancelled = [];
	    this.actionDispatched = [];
	  }

	  var _proto = SagaMonitorRegistry.prototype;

	  _proto.register = function register(moniter) {
	    if (!moniter || !object(moniter)) {
	      throw new Error("SagaMoniterRegistry.register: Invalid moniter");
	    }

	    if (func(moniter.effectTriggered)) {
	      this.effectTriggered.push(moniter.effectTriggered);
	    }

	    if (func(moniter.effectResolved)) {
	      this.effectResolved.push(moniter.effectResolved);
	    }

	    if (func(moniter.effectRejected)) {
	      this.effectRejected.push(moniter.effectRejected);
	    }

	    if (func(moniter.effectCancelled)) {
	      this.effectCancelled.push(moniter.effectCancelled);
	    }

	    if (func(moniter.actionDispatched)) {
	      this.actionDispatched.push(moniter.actionDispatched);
	    }
	  };

	  _proto.deregister = function deregister(moniter) {
	    if (!moniter || !object(moniter)) {
	      throw new Error("SagaMoniterRegistry.deregister: Invalid moniter");
	    }

	    if (func(moniter.effectTriggered)) {
	      this.effectTriggered = this.effectTriggered.filter(function (item) {
	        return item !== moniter.effectTriggered;
	      });
	    }

	    if (func(moniter.effectResolved)) {
	      this.effectResolved = this.effectResolved.filter(function (item) {
	        return item !== moniter.effectResolved;
	      });
	    }

	    if (func(moniter.effectRejected)) {
	      this.effectRejected = this.effectRejected.filter(function (item) {
	        return item !== moniter.effectRejected;
	      });
	    }

	    if (func(moniter.effectCancelled)) {
	      this.effectCancelled = this.effectCancelled.filter(function (item) {
	        return item !== moniter.effectCancelled;
	      });
	    }

	    if (func(moniter.actionDispatched)) {
	      this.actionDispatched = this.actionDispatched.filter(function (item) {
	        return item !== moniter.actionDispatched;
	      });
	    }
	  };

	  _proto.destroy = function destroy() {
	    this.effectTriggered = [];
	    this.effectResolved = [];
	    this.effectRejected = [];
	    this.effectCancelled = [];
	    this.actionDispatched = [];
	  };

	  _proto.getCombinedMonitor = function getCombinedMonitor() {
	    var _this = this;

	    return {
	      effectTriggered: function effectTriggered(options) {
	        if (!_this.effectTriggered.length) return;

	        _this.effectTriggered.forEach(function (item) {
	          try {
	            item(options);
	          } catch (e) {
	            log("Error when executing saga moniter `effectTriggered`.", "error", e);
	          }
	        });
	      },
	      effectResolved: function effectResolved(effectId, res) {
	        if (!_this.effectResolved.length) return;

	        _this.effectResolved.forEach(function (item) {
	          try {
	            item(effectId, res);
	          } catch (e) {
	            log("Error when executing saga moniter `effectResolved`.", "error", e);
	          }
	        });
	      },
	      effectRejected: function effectRejected(effectId, res) {
	        if (!_this.effectRejected.length) return;

	        _this.effectRejected.forEach(function (item) {
	          try {
	            item(effectId, res);
	          } catch (e) {
	            log("Error when executing saga moniter `effectRejected`.", "error", e);
	          }
	        });
	      },
	      effectCancelled: function effectCancelled(effectId) {
	        if (!_this.effectCancelled.length) return;

	        _this.effectCancelled.forEach(function (item) {
	          try {
	            item(effectId);
	          } catch (e) {
	            log("Error when executing saga moniter `effectCancelled`.", "error", e);
	          }
	        });
	      },
	      actionDispatched: function actionDispatched(action$$1) {
	        if (!_this.actionDispatched.length) return;

	        _this.actionDispatched.forEach(function (item) {
	          try {
	            item(action$$1);
	          } catch (e) {
	            log("Error when executing saga moniter `actionDispatched`.", "error", e);
	          }
	        });
	      }
	    };
	  };

	  return SagaMonitorRegistry;
	}();

	var standardliseActionTypesParameter = function standardliseActionTypesParameter(actionTypes) {
	  var newActionList = {};

	  if (symbol(actionTypes)) {
	    newActionList[symbolToString(actionTypes)] = actionTypes;
	  } else if (array(actionTypes) && actionTypes.length) {
	    actionTypes.forEach(function (actionType) {
	      if (!symbol(actionType)) {
	        throw new Error("ActionRegistry: Action type must be a symbol.");
	      }

	      newActionList[symbolToString(actionType)] = actionType;
	    });
	  } else if (object(actionTypes)) {
	    Object.keys(actionTypes).forEach(function (key) {
	      if (!symbol(actionTypes[key])) {
	        throw new Error("ActionRegistry: Action type must be a symbol.");
	      }

	      newActionList[symbolToString(actionTypes[key])] = actionTypes[key];
	    });
	  } else {
	    throw new Error("ActionRegistry: actionTypes must be a symbol or a list / array of symbols.");
	  }

	  return newActionList;
	};

	var ActionRegistry =
	/*#__PURE__*/
	function () {
	  function ActionRegistry() {
	    this.pathRegistry = new PathRegistry();
	  }

	  var _proto = ActionRegistry.prototype;

	  _proto.destroy = function destroy() {
	    this.pathRegistry.destroy();
	  };

	  _proto.register = function register(namespace, actionTypes) {
	    namespace = normalize(namespace);
	    var newActionList = standardliseActionTypesParameter(actionTypes);

	    if (this.pathRegistry.exist(namespace)) {
	      var data = this.pathRegistry.getPathData(namespace);
	      var actionList = Object.assign({}, object(data.actionList) ? data.actionList : {}, newActionList);
	      this.pathRegistry.setPathData(namespace, _extends_1({}, data, {
	        actionList: actionList
	      }));
	    } else {
	      this.pathRegistry.add(namespace, {
	        actionList: newActionList
	      });
	    }
	  };

	  _proto.deregister = function deregister(namespace, actionTypes) {
	    if (actionTypes === void 0) {
	      actionTypes = null;
	    }

	    namespace = normalize(namespace);
	    if (!this.pathRegistry.exist(namespace)) return;

	    if (!actionTypes) {
	      this.pathRegistry.remove(namespace);
	    } else {
	      var newActionList = Object.values(standardliseActionTypesParameter(actionTypes));

	      var _this$pathRegistry$ge = this.pathRegistry.getPathData(namespace),
	          actionList = _this$pathRegistry$ge.actionList;

	      var actionListKeys = Object.keys(actionList).filter(function (key) {
	        return newActionList.indexOf(actionList[key]) === -1;
	      });

	      if (!actionListKeys.length) {
	        this.pathRegistry.remove(namespace);
	      } else {
	        actionListKeys.forEach(function (key) {
	          delete actionList[key];
	        });
	        this.pathRegistry.setPathData({
	          actionList: actionList
	        });
	      }
	    }
	  };

	  _proto.findNamespaceByActionType = function findNamespaceByActionType(actionType) {
	    return this.pathRegistry.searchPathByPathData(function (_ref) {
	      var actionList = _ref.actionList;
	      return Object.values(actionList).indexOf(actionType) !== -1;
	    });
	  };

	  _proto.serialiseAction = function serialiseAction(action$$1) {
	    if (!action(action$$1)) {
	      throw new Error("serialiseAction: Cannot action parameter is not a valid Action.");
	    }

	    var namespace = action$$1.namespace,
	        type = action$$1.type;

	    if (!namespace) {
	      throw new Error("serialiseAction: Cannot locate namespace property from action parameter");
	    }

	    var _this$pathRegistry$ge2 = this.pathRegistry.getPathData(namespace),
	        actionList = _this$pathRegistry$ge2.actionList;

	    if (!object(actionList) || !Object.keys(actionList).length || !Object.values(actionList).indexOf(action$$1) === -1) {
	      throw new Error("serialiseAction: the action type is not register yet.");
	    }

	    var newAction = _extends_1({}, action$$1, {
	      type: symbolToString(type)
	    });

	    if (action$$1[NAMESPACED] === true) {
	      newAction[symbolToString(NAMESPACED)] = true;
	    }

	    return JSON.stringify(newAction);
	  };

	  _proto.deserialiseAction = function deserialiseAction(actionJson) {
	    var action$$1 = JSON.parse(actionJson);

	    if (!action$$1 || !action$$1.namespace) {
	      throw new Error("Cannot deserialise action without namespace property!");
	    }

	    if (action$$1[symbolToString(NAMESPACED)] === true) {
	      action$$1[NAMESPACED] = true;
	    }

	    var _this$pathRegistry$ge3 = this.pathRegistry.getPathData(action$$1.namespace),
	        actionList = _this$pathRegistry$ge3.actionList;

	    if (!object(actionList)) {
	      throw new Error("Cannot deserialise unregistered action!");
	    }

	    var type = actionList[action$$1.type];

	    if (!type) {
	      throw new Error("Cannot deserialise unregistered action!");
	    }

	    action$$1.type = type;
	    return action$$1;
	  };

	  return ActionRegistry;
	}();

	var NamespaceRegistry =
	/*#__PURE__*/
	function () {
	  function NamespaceRegistry(appContainer) {
	    this.appContainer = appContainer;
	    this.pathRegistry = new PathRegistry();
	  }

	  var _proto = NamespaceRegistry.prototype;

	  _proto.destroy = function destroy() {
	    this.pathRegistry.destroy();
	    this.appContainer = null;
	  };

	  _proto.registerComponentManager = function registerComponentManager(cm) {
	    var namespace = cm.namespace,
	        options = cm.options;
	    var namespaceInitCallback = options.namespaceInitCallback,
	        namespaceDestroyCallback = options.namespaceDestroyCallback,
	        actionTypes = options.actionTypes;

	    if (this.pathRegistry.exist(namespace)) {
	      var _this$pathRegistry$ge = this.pathRegistry.getPathData(namespace),
	          cmList = _this$pathRegistry$ge.cmList;

	      cmList.push(cm);
	    } else {
	      if (actionTypes) {
	        this.appContainer.actionRegistry.register(namespace, actionTypes);
	      }

	      this.pathRegistry.add(namespace, {
	        cmList: [cm],
	        namespaceData: func(namespaceInitCallback) ? namespaceInitCallback(cm) : {},
	        namespaceInitCallback: namespaceInitCallback,
	        namespaceDestroyCallback: namespaceDestroyCallback,
	        actionTypes: actionTypes
	      });
	    }
	  };

	  _proto.deregisterComponentManager = function deregisterComponentManager(cm) {
	    var namespace = cm.namespace;

	    var _this$pathRegistry$ge2 = this.pathRegistry.getPathData(namespace),
	        cmList = _this$pathRegistry$ge2.cmList,
	        namespaceDestroyCallback = _this$pathRegistry$ge2.namespaceDestroyCallback,
	        namespaceData = _this$pathRegistry$ge2.namespaceData;

	    cmList = cmList.filter(function (item) {
	      return item !== cm;
	    });

	    if (!cmList.length) {
	      this.pathRegistry.remove(namespace);
	      this.appContainer.actionRegistry.deregister(namespace);

	      if (func(namespaceDestroyCallback)) {
	        namespaceDestroyCallback(namespaceData);
	      }
	    }
	  };

	  _proto.getData = function getData(namespace) {
	    var _this$pathRegistry$ge3 = this.pathRegistry.getPathData(namespace),
	        namespaceData = _this$pathRegistry$ge3.namespaceData;

	    return namespaceData;
	  };

	  _proto.foreach = function foreach(iteratee) {
	    this.pathRegistry.foreach(function (_ref, namespace) {
	      var namespaceData = _ref.namespaceData;
	      return iteratee(namespaceData, namespace);
	    });
	  };

	  _proto.map = function map(iteratee) {
	    return this.pathRegistry.map(function (_ref2, namespace) {
	      var namespaceData = _ref2.namespaceData;
	      return iteratee(namespaceData, namespace);
	    });
	  };

	  return NamespaceRegistry;
	}();

	var actionBlackList =
	/*#__PURE__*/
	Object.keys(actionTypes).map(function (idx) {
	  return actionTypes[idx];
	}).concat(
	/*#__PURE__*/
	Object.keys(actionTypes$1).map(function (idx) {
	  return actionTypes$1[idx];
	}));
	var defaultDevToolOptions = {
	  actionSanitizer: function actionSanitizer(action$$1) {
	    return _extends_1({}, action$$1, {
	      type: symbol(action$$1.type) ? symbolToString(action$$1.type) : action$$1.type
	    });
	  },
	  predicate: function predicate(state, action$$1) {
	    return action$$1 && actionBlackList.indexOf(action$$1.type) === -1;
	  }
	};
	var defaultOptions$2 = {
	  reducer: null,
	  initState: {},
	  middlewares: [],
	  reduxDevToolsDevOnly: true,
	  //-- https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md#windowdevtoolsextensionconfig
	  devToolOptions:
	  /*#__PURE__*/
	  _extends_1({}, defaultDevToolOptions),
	  //-- https://redux-saga.js.org/docs/api/index.html#createsagamiddlewareoptions
	  sagaMiddlewareOptions: {},
	  isServerSideRendering: false
	};

	var getComposeEnhancers = function getComposeEnhancers(devOnly, options) {
	  /* eslint-disable-next-line no-underscore-dangle */
	  if (typeof window !== "object" || !window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) return compose;
	  if (devOnly && !isDevMode()) return compose;

	  var devToolOptions = _extends_1({}, options ? options : {});
	  /* eslint-disable-next-line no-underscore-dangle */


	  return window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devToolOptions);
	};

	var AppContainer =
	/*#__PURE__*/
	function () {
	  function AppContainer(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    this.store = null;
	    this.sagaMonitorRegistry = new SagaMonitorRegistry();
	    this.actionRegistry = new ActionRegistry();
	    this.namespaceRegistry = new NamespaceRegistry(this);

	    var containerCreationOptions = _extends_1({}, defaultOptions$2, options);

	    if (options && options.devToolOptions) {
	      containerCreationOptions.devToolOptions = _extends_1({}, defaultDevToolOptions, options.devToolOptions);
	    }

	    var composeEnhancers = getComposeEnhancers(containerCreationOptions.reduxDevToolsDevOnly, containerCreationOptions.devToolOptions);
	    var sagaMiddleware = createSagaMiddleware__default(_extends_1({}, containerCreationOptions.sagaMiddlewareOptions, {
	      sagaMonitor: this.sagaMonitorRegistry.getCombinedMonitor()
	    }));
	    var middlewares = containerCreationOptions.middlewares.concat([
	    /**
	     * Make sure `sagaMiddleware` is the last in the list
	     * Therefore, reducers are run before saga.
	     */
	    sagaMiddleware]);
	    this.eventEmitters = [];
	    this.componentRegistry = new ComponentRegistry(this, {
	      isServerSideRendering: containerCreationOptions.isServerSideRendering
	    });
	    this.reducerRegistry = new ReducerRegistry(this);
	    this.sagaRegistry = new SagaRegistry(this);
	    this.store = createStore(this.reducerRegistry.createGlobalReducer(containerCreationOptions.reducer), _extends_1({}, containerCreationOptions.initState), composeEnhancers(applyMiddleware.apply(void 0, middlewares)));
	    this.hostSagaTask = sagaMiddleware.run(this.sagaRegistry.createHostSaga());
	  }

	  var _proto = AppContainer.prototype;

	  _proto.registerComponent = function registerComponent(componentInstance, options) {
	    return this.componentRegistry.register(componentInstance, options);
	  };

	  _proto.deregisterComponent = function deregisterComponent(componentInstance) {
	    this.componentRegistry.deregister(componentInstance);
	  };
	  /**
	   * This function is mainly used for server side rendering.
	   * i.e. To decide to when the initial data loading is finised
	   * and when it is ready to create a snapshot of the redux store
	   * via appContainer.store.getState()
	   *
	   * You shouldn't need it for implmenting any logic
	   *
	   */


	  _proto.subscribeActionDispatch = function subscribeActionDispatch(func$$1) {
	    this.sagaMonitorRegistry.register({
	      actionDispatched: func$$1
	    });
	  }; // --- an utility mainly designed for server side rendering.


	  _proto.waitForActionsUntil = function waitForActionsUntil(testerFunc, timeout) {
	    var _this = this;

	    if (timeout === void 0) {
	      timeout = 5000;
	    }

	    return new Promise(function (resolve, reject) {
	      setTimeout(function () {
	        var error = new Error("waitForActionsUntil timeout");
	        error.isTimeout = true;
	        reject(error);
	      }, timeout);

	      _this.subscribeActionDispatch(function (action$$1) {
	        if (testerFunc(action$$1)) {
	          resolve();
	        }
	      });
	    });
	  };
	  /**
	   * This function is mainly used for server side rendering.
	   * i.e. Send out actions (if necessary) to trigger initial data loading
	   *
	   * You shouldn't need it for implmenting any logic
	   *
	   */


	  _proto.dispatch = function dispatch(action$$1, relativeDispatchPath) {
	    if (relativeDispatchPath === void 0) {
	      relativeDispatchPath = "";
	    }

	    var pc = new PathContext("");
	    var namespacedAction$$1 = pc.convertNamespacedAction(action$$1, relativeDispatchPath); // --- query action Type's original namespace so that it can be serialised correctly if needed

	    var namespace = this.actionRegistry.findNamespaceByActionType(namespacedAction$$1.type);

	    if (!namespace) {
	      log("Cannot locate namespace for Action `" + symbolToString(namespacedAction$$1.type) + "`: `" + symbolToString(namespacedAction$$1.type) + "` needs to be registered otherwise the action won't be serializable.");
	    } else {
	      namespacedAction$$1.namespace = namespace;
	    }

	    return this.store.dispatch(namespacedAction$$1);
	  };

	  _proto.destroy = function destroy() {
	    this.componentRegistry.destroy();

	    if (this.hostSagaTask) {
	      this.hostSagaTask.cancel();
	      this.hostSagaTask = null;
	    }

	    this.sagaRegistry.destroy();
	    this.reducerRegistry.destroy();
	    this.sagaMonitorRegistry.destroy();
	    this.actionRegistry.destroy();
	    this.namespaceRegistry.destroy();
	  };

	  return AppContainer;
	}();

	var APP_CONTAINER_KEY = "appContainer";
	var defaultAppContainer = null;
	function createAppContainer(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  if (defaultAppContainer) {
	    log("AppContainerUtils.createAppContainer: Existing appContainer found. " + "The appContainer options supplied was ignored. " + "Existing appContainer will be used.", "warn");
	    return defaultAppContainer;
	  }

	  var ac = new AppContainer(options);
	  defaultAppContainer = ac;
	  return ac;
	}
	function getAppContainer(componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  if (componentInstance) {
	    if (componentInstance.props && componentInstance.props[APP_CONTAINER_KEY]) return componentInstance.props[APP_CONTAINER_KEY];
	    if (componentInstance.context && componentInstance.context[APP_CONTAINER_KEY]) return componentInstance.context[APP_CONTAINER_KEY];
	  }

	  if (!defaultAppContainer) {
	    defaultAppContainer = createAppContainer();
	  }

	  return defaultAppContainer;
	}
	function registerComponent(componentInstance, options) {
	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.registerComponent(componentInstance, options);
	}
	function deregisterComponent(componentInstance) {
	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.deregisterComponent(componentInstance);
	}
	function registerSaga(saga, sagaOptions, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.sagaRegistry.register(saga, sagaOptions);
	}
	function deregisterSaga(pathOrTask, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.sagaRegistry.deregister(pathOrTask);
	}
	function registerReducer(reducer, reducerOptions, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.reducerRegistry.register(reducer, reducerOptions);
	}
	function deregisterReducer(path, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.reducerRegistry.deregister(path);
	}
	function registerActions(namespace, actions, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.actionRegistry.register(namespace, actions);
	}
	function serialiseAction(action$$1, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.actionRegistry.serialiseAction(action$$1);
	}
	function deserialiseAction(actionJson, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.actionRegistry.deserialiseAction(actionJson);
	}
	function findNamespaceByActionType(actionType, componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  return appContainer.actionRegistry.findNamespaceByActionType(actionType);
	}
	function destroyAppContainer(componentInstance) {
	  if (componentInstance === void 0) {
	    componentInstance = null;
	  }

	  var appContainer = getAppContainer(componentInstance);
	  appContainer.destroy();

	  if (appContainer === defaultAppContainer) {
	    defaultAppContainer = null;
	  }
	}
	/**
	 * Update AppContainerRetrieveKey
	 * This key is used by AppContainerUtils for looking up `appContainer` instance
	 * from either Component Instance props or context
	 * @param {string} newKey
	 * return Current key
	 */

	function updateAppContainerRetrieveKey(newKey) {
	  var currentKey = APP_CONTAINER_KEY;
	  APP_CONTAINER_KEY = newKey;
	  return currentKey;
	}

	var AppContainerUtils = /*#__PURE__*/Object.freeze({
		createAppContainer: createAppContainer,
		getAppContainer: getAppContainer,
		registerComponent: registerComponent,
		deregisterComponent: deregisterComponent,
		registerSaga: registerSaga,
		deregisterSaga: deregisterSaga,
		registerReducer: registerReducer,
		deregisterReducer: deregisterReducer,
		registerActions: registerActions,
		serialiseAction: serialiseAction,
		deserialiseAction: deserialiseAction,
		findNamespaceByActionType: findNamespaceByActionType,
		destroyAppContainer: destroyAppContainer,
		updateAppContainerRetrieveKey: updateAppContainerRetrieveKey
	});

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	var inheritsLoose = _inheritsLoose;

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	var assertThisInitialized = _assertThisInitialized;

	var _marked$1 =
	/*#__PURE__*/
	regenerator.mark(forwarderSaga);
	/**
	 * A helper container component used to forward actions to another namespace
	 */

	var ActionForwarder =
	/*#__PURE__*/
	function (_React$Component) {
	  inheritsLoose(ActionForwarder, _React$Component);

	  function ActionForwarder(props) {
	    var _this;

	    _this = _React$Component.call(this, props) || this;
	    _this.appContainer = getAppContainer();
	    _this.componentManager = registerComponent(assertThisInitialized(assertThisInitialized(_this)), {
	      namespace: "io.github.t83714/ActionForwarder",
	      saga: forwarderSaga.bind(assertThisInitialized(assertThisInitialized(_this))),
	      // --- By default, component will not accept any incoming multicast action.
	      // --- "*" will allow any action types to be accepted
	      // --- No limit to actions that are sent out
	      allowedIncomingMulticastActionTypes: "*"
	    });
	    return _this;
	  }

	  var _proto = ActionForwarder.prototype;

	  _proto.render = function render() {
	    return null;
	  };

	  return ActionForwarder;
	}(React.Component);

	ActionForwarder.propTypes = {
	  namespacePrefix: PropTypes.string.isRequired,
	  pattern:
	  /*#__PURE__*/
	  PropTypes.oneOfType([PropTypes.symbol, PropTypes.func,
	  /*#__PURE__*/
	  PropTypes.arrayOf(
	  /*#__PURE__*/
	  PropTypes.oneOfType([PropTypes.string, PropTypes.func]))]),
	  relativeDispatchPath: PropTypes.string,
	  transformer:
	  /*#__PURE__*/
	  PropTypes.oneOfType([PropTypes.symbol, PropTypes.func])
	};

	function forwarderSaga(effects) {
	  return regenerator.wrap(function forwarderSaga$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.next = 2;
	          return effects.takeEvery(this.props.pattern ? this.props.pattern : "*",
	          /*#__PURE__*/
	          regenerator.mark(function _callee(action$$1) {
	            var newAction, relativeDispatchPath;
	            return regenerator.wrap(function _callee$(_context) {
	              while (1) {
	                switch (_context.prev = _context.next) {
	                  case 0:
	                    if (!(action$$1.currentSenderPath === this.componentManager.fullPath)) {
	                      _context.next = 2;
	                      break;
	                    }

	                    return _context.abrupt("return");

	                  case 2:
	                    newAction = actionTransformer.call(this, action$$1, this.props.transformer); //--- namespaced forward

	                    /**
	                     * namespaced forward
	                     * `ActionForwarder`'s current namespace path is:
	                     * `${props.namespacePrefix}/io.github.t83714/ActionForwarder/${this.componentManager.componentId}`
	                     * Add `../../../` to `props.relativeDispatchPath` so that relative namespace path
	                     * will start from `${props.namespace}`.
	                     * This might be easier for people to use `ActionForwarder` as we don't need to
	                     * always add `three levels up` in order to throw action out of `ActionForwarder`
	                     */

	                    relativeDispatchPath = this.props.relativeDispatchPath ? "../../../" + this.props.relativeDispatchPath : "";
	                    _context.next = 6;
	                    return effects.put(newAction, relativeDispatchPath);

	                  case 6:
	                  case "end":
	                    return _context.stop();
	                }
	              }
	            }, _callee, this);
	          }).bind(this));

	        case 2:
	        case "end":
	          return _context2.stop();
	      }
	    }
	  }, _marked$1, this);
	}

	function actionTransformer(action$$1, transformer) {
	  if (!transformer) return action$$1;
	  var newAction = action$$1;

	  if (symbol(transformer)) {
	    newAction = _extends_1({}, action$$1, {
	      type: transformer
	    });
	  } else if (func(transformer)) {
	    newAction = transformer(action$$1);
	  }

	  return newAction;
	}

	exports.AppContainer = AppContainer;
	exports.AppContainerUtils = AppContainerUtils;
	exports.ActionForwarder = ActionForwarder;
	exports.utils = utils;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
